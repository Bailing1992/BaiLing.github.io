---
layout: post
title: "算法 系列 二分搜索"
subtitle: '基础数据结构...'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - algorithm
---

## 寻找一个数

```
int binarySearch(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1; // 注意
    while(left <= right) {
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid;
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```

1. 为什么 while 循环的条件中是 <=，⽽不是 < ？

答：因为初始化 right 的赋值是 nums.length - 1，即最后⼀个元素的索引，⽽
不是 nums.length。

## 寻找左侧边界的⼆分搜索

```
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意
    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}
```
## 寻找右侧边界的⼆分查找

```
int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    right = nums.length;
    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    if (left == 0) return -1;
    return nums[left-1] == target ? (left-1) : -1;
}
```