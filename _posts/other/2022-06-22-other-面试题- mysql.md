---
layout: post
title: "面试题- Mysql汇总"
author: "lichao"
header-img: "img/post/bg/host.png"
catalog: true
tags:
  - other
---

## 数据库索引创建时的思考
1. 什么时候需要建立索引
2. 什么时候不应该创建索引

**什么时候需要建立索引:**            
- 作为主键的列上，强制该列的唯一性和组织表中数据的排列结构。
- 在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度。
- 在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的。
- 在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- 在经常使用在 where 子句中的列上面创建索引，加快条件的判断速度。

**什么时候不应该创建索引:**       
- 在查询中很少使用或者作为参考的列不应该创建索引。
- 对于那些只有很少数据值的列也不应该增加索引（比如性别，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度）。
- 对于那些定义为text，image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。
- 当修改性能远远大于检索性能时，不应该创建索引，因为修改性能和检索性能是矛盾的。


## SQL 中 INNER、LEFT、RIGHT JOIN 的区别
**答案:**
- A INNER JOIN B ON……：内联操作，将符合 ON 条件的 A 表和 B 表结果均搜索出来，然后合并为一个结果集。
- A LEFT JOIN B ON……：左联操作，左联顾名思义是，将符合 ON 条件的 B 表结果搜索出来，然后左联到 A 表上，然后将合并后的 A 表输出。
- A RIGHT JOIN B ON……：右联操作，右联顾名思义是，将符合 ON 条件的 A 表结果搜索出来，然后右联到 B 表上，然后将合并后的 B 表输出。



## 乐观锁与悲观锁的区别
悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。[1] 悲观锁假定其他用户企图访问或者改变你正在访问、更改的对象的概率是很高的，因此在悲观锁的环境中，在你开始改变此对象之前就将该对象锁住，并且直到你提交了所作的更改之后才释放锁。悲观的缺陷是不论是页锁还是行锁，加锁的时间可能会很长，这样可能会长时间的限制其他用户的访问，也就是说悲观锁的并发访问性不好。

乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。[1] 乐观锁不能解决脏读的问题。 乐观锁则认为其他用户企图改变你正在更改的对象的概率是很小的，因此乐观锁直到你准备提交所作的更改时才将对象锁住，当你读取以及改变该对象时并不加锁。可见乐观锁加锁的时间要比悲观锁短，乐观锁可以用较大的锁粒度获得较好的并发访问性能。但是如果第二个用户恰好在第一个用户提交更改之前读取了该对象，那么当他完成了自己的更改进行提交时，数据库就会发现该对象已经变化了，这样，第二个用户不得不重新读取该对象并作出更改。这说明在乐观锁环境中，会增加并发用户读取对象的次数。

从数据库厂商的角度看，使用乐观的页锁是比较好的，尤其在影响很多行的批量操作中可以放比较少的锁，从而降低对资源的需求提高数据库的性能。再考虑聚集索引。在数据库中记录是按照聚集索引的物理顺序存放的。如果使用页锁，当两个用户同时访问更改位于同一数据页上的相邻两行时，其中一个用户必须等待另一个用户释放锁，这会明显地降低系统的性能。interbase和大多数关系数据库一样，采用的是乐观锁，而且读锁是共享的，写锁是排他的。可以在一个读锁上再放置读锁，但不能再放置写锁；你不能在写锁上再放置任何锁。锁是目前解决多用户并发访问的有效手段。  

[了解更多](https://bailing1992.github.io/2019/09/14/mysql-%E7%B3%BB%E5%88%97-%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81/)



## MySQL 分库分表环境下全局 ID 生成方案
在大型互联网应用中，随着用户数的增加，为了提高应用的性能，我们经常需要对数据库进行分库分表操作。在单表时代，可以完全依赖于数据库的自增ID来唯一标识一个用户或数据对象。但是当对数据库进行了分库分表后，就不能依赖于每个表的自增ID来全局唯一标识这些数据了。因此，需要提供一个全局唯一的ID号生成策略来支持分库分表的环境。

---
**答案:**

**1、数据库自增ID——来自 Flicker 的解决方案**

因为 MySQL 本身支持 auto_increment 操作，很自然地，会想到借助这个特性来实现这个功能。Flicker 在解决全局 ID 生成方案里就采用了 MySQL 自增长 ID 的机制（auto_increment + replace into + MyISAM）

先创建单独的数据库(eg:ticket)，然后创建一个表：
```sql
CREATE TABLE Tickets64 (
      id bigint(20) unsigned NOT NULL auto_increment,
      stub char(1) NOT NULL default '',
      PRIMARY KEY (id),
      UNIQUE KEY stub (stub)
  ) ENGINE=MyISAM
```


> REPLACE INTO 用于实时覆盖写入数据。写入数据时，会先根据主键判断待写入的数据是否已经存在于表中，并根据判断结果选择不同的方式写入数据：
> - 如果待写入数据已经存在，则先删除该行数据，然后插入新的数据。
> - 如果待写入数据不存在，则直接插入新数据。


当插入记录后，执行 ```SELECT * from Tickets64```，查询结果就是这样的：

+-------------------+------+

| id                | stub |

+-------------------+------+

| 72157623227190423 |  a |

+-------------------+------+



在我们的应用端需要做下面这两个操作，在一个事务会话里提交：
```sql
REPLACE INTO Tickets64 (stub) VALUES ('a');
SELECT LAST_INSERT_ID();
```
这样我们就能拿到不断增长且不重复的 ID 了。

从高可用角度考虑，接下来就要解决单点故障问题：Flicker 启用了两台数据库服务器来生成 ID，通过区分 auto_increment 的起始值和步长来生成奇偶数的 ID。

最后，在客户端只需要通过轮询方式取 ID 就可以了。

优点：
  - 充分借助数据库的自增 ID 机制，提供高可靠性，生成的 ID 有序。
缺点：
  - 占用两个独立的 MySQL 实例，有些浪费资源，成本较高。

---

**2、独立的应用程序——来自 Twitter 的解决方案**

Twitter 在把存储系统从 MySQL 迁移到 Cassandra 的过程中由于 Cassandra 没有顺序 ID 生成机制，于是自己开发了一套全局唯一 ID 生成服务：Snowflake。GitHub地址：https://github.com/twitter/snowflake。根据 twitter 的业务需求，snowflake 系统生成 64 位的 ID。
由 3 部分组成，最高位是符号位，始终为 0：
- 41 位的时间序列（精确到毫秒，41 位的长度可以使用 69 年）
- 10 位的机器标识（10 位的长度最多支持部署 1024 个节点）
- 12 位的计数顺序号（12 位的计数顺序号支持每个节点每毫秒产生4096个 ID 序号）

优点：
  - 高性能，低延迟；
  - 独立的应用；
  - 按时间有序。
缺点：
  - 需要独立的开发和部署。


