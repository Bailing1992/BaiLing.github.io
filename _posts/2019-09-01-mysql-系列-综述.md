---
layout: post
title: "MySQL 系列 综述"
subtitle: '《Mysql 技术内幕：InnoDB存储引擎》'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - mysql
---

> 主要介绍《Mysql 技术内幕：InnoDB存储引擎》第一、二章相关知识点，

# 相关概念
#### 数据库
文件集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合.  
#### 数据库实例
数据库实例是真正用于操作数据库文件的一个进程.  MySQL为一个单进程多线程架构的数据库
#### OLTP（联机事务处理-Online Transaction Processing）
表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。

OLTP比较常用的设计与优化方式为Cache技术与B-tree索引技术，Cache决定了很多语句不需要从磁盘子系统获得数据，所以，Web cache与Oracle data buffer对OLTP系统是很重要的。另外，在索引使用方面，语句越简单越好，这样执行计划也稳定，而且一定要使用绑定变量，减少语句解析，尽量减少表关联，尽量减少分布式事务，基本不使用分区技术、MV技术、并行技术及位图索引。因为并发量很高，批量更新时要分批快速提交，以避免阻塞的发生。 OLTP 系统是一个数据块变化非常频繁，SQL 语句提交非常频繁的系统。 对于数据块来说，应尽可能让数据块保存在内存当中，对于SQL来说，尽可能使用变量绑定技术来达到SQL重用，减少物理I/O 和重复的SQL 解析，从而极大的改善数据库的性能。

对比OLAP（联机分析处理，亦即DSS决策分析系统）：就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。磁盘子系统的吞吐量则往往取决于磁盘的个数，这个时候，Cache基本是没有效果的，数据库的读写类型基本上是db file scattered read与direct path read/write。应尽量采用个数比较多的磁盘以及比较大的带宽，如4Gb的光纤接口。

*引申：*
数据库与数据仓库的区别；

#### 全文索引     
MySQL5.6.24上InnoDB引擎也加入了全文索引.  
MySQL 5.7.6之前，全文索引只支持英文全文索引，不支持中文全文索引，需要利用分词器把中文段落预处理拆分成单词，然后存入数据库.  
MySQL 5.7.6开始，MySQL内置了ngram全文解析器，用来支持中文、日文、韩文分词    
全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果    
**注：分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符。**.  
*引申：*.  
倒排索引：全文检索的索引被称为倒排索引，之所以成为倒排索引，是因为将每一个单词作为索引项，根据该索引项查找包含该单词的文本。因此，索引都是单词和唯一记录文本的标示是一对多的关系。将索引单词排序，根据排序后的单词定位包含该单词的文本。

#### MVCC（多版本并发控制）
解决读-写冲突问题。读不用加锁，通过一定机制生成一个数据请求时间点时的一致性数据快照， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。这样在读操作的时候不需要阻塞写操作，写操作时不需要阻塞读操作   
Mysql的大多数事务型存储引擎实现都不是简单的行级锁，基于并发性能考虑，一般都实现了MVCC多版本并发控制。MVCC是通过保存数据在某个时间点的快照来实现的。不管事务执行多长时间，事务看到的数据都是一致的   
*读操作：*
读操作分成两类：快照读和当前读   
*快照读:*
简单的select操作属于快照读，不加锁.  
*当前读:*.  
特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁   
*MVCC优缺点：*.  
MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作   
*数据结构:*  
InnoDB的内部实现中为每一行数据增加了三个隐藏列用于实现MVCC   
*算法策略：*   

* select时，InnoDB 会根据两个条件来检查每行记录：  
InnoDB只查找版本(DB_TRX_ID)早于当前事务版本的数据行（行的系统版本号<=事务的系统版本号,这样可以确保数据行要么是在开始之前已经存在了，要么是事务自身插入或修改过的）
行的删除版本号(DB_ROLL_PTR)要么未定义（未更新过），要么大于当前事务版本号（在当前事务开始之后更新的）。这样可以确保事务读取到的行，在事务开始之前未被删除。
* insert时，InnoDB为新插入的每一行保存当前系统版本号作为行版本号  
* delete时，InnoDB为删除的每一行保存当前的系统版本号作为行删除标识。
* update时，InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识. 

> 引申：  
next-key locking的策略：


#### checkpoint技术
数据经过更新或者删除之后，数据页变为脏页，需要刷回磁盘，在事务提交时，先写重做日志，再修改页，再在合适的时机刷回磁盘。这样即使宕机，也可以通过重做日志来恢复数据。（这即为ACID的Durability）。这个时机就是Checkpoint技术。这个技术解决了如下问题：

缩短数据库恢复时间.  
缓冲池不够用时，将脏页刷新到磁盘.  
重做日志不可用时，刷新脏页.  
   当数据库宕机之后，只需对checkpoint后的重做日志进行恢复，就大大缩短了恢复时间。当一部分重做日志不再需要的时候，这部分就可以被覆盖重用，在复写前，会强制产生checkpoint，将缓冲池的脏页刷新到当前重做日志的位置.  
   对于InnoDB而言，是通过LSN来标记版本的，LSN是8字节的数字，单位是字节，每个页有LSN，重做日志也有LSN.  
   Checkpoint的发生时间和条件，以及脏页的选择都非常复杂。InnoDB根据不同情况将Checkpoint分为两种：

* Sharp Checkpoint
* Fuzzy Checkpoint.  
Sharp Checkpoint在数据库关闭时，将所有的脏页都刷新回磁盘。在运行时是不可能这么做的，所以采用Fuzzy Checkpoint，有这么几种情况会触发:

* Master Thread Checkpoint
* FLUSH_LRU_LIST Checkpoint
* Async/Sync Flush Checkpoint
* Dirty Page too much Checkpoint


#### 刷新邻接页
当刷新一个脏页时，InnoDB存储引擎会检测该页所在区的所有页，如果是脏页，那么一起刷新。通过AIO可以将多个IO写入操作合并为一个IO操作。

> AIO(Asynchronous IO),数据库系统采用AIO的方式来处理磁盘操作。
#### 伙伴算法：
#### 哈夫曼编码

-----

# 相关问题
#### MySQL的特点
单进程多线程架构
插件式的表存储引擎
开源
#### MySQL 体系结构及各个模块的作用（sql语句的执行流程）
连接池组建
管理服务和工具组件
SQL接口组件
分析器组件
优化器组件
缓冲组件
插件式存储引擎
物理文件
#### Innodb 存储引擎的特点
* 其设计目标主要面向在线事务处理（OLTP）的应用         
* 完整支持ACID事物，实现SQL标准的4中隔离级别
* **行锁设计**      
* **支持外键**      
* **非锁定读（默认读取操作不会产生锁）**     
* 支持 MVCC（多版本并发控制，以获取高并发性）
* 采用聚集的方式（每张表都按主键的顺序存放）
* 支持一致性非锁定读（默认读取操作不会产生锁）
* 支持全文索引
* 支持插入缓存
* 支持二次写
* 支持自适应哈希索引
* 支持预读

#### MySQL中myisam与innodb的不同之处
不支持事务
不支持表锁
不支持全文索引
默认支持256T的单表数据（5.0）

#### innodb的线程模型
InnoDB存储引擎是多线程模型：
* master线程（最高优先级）：负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓存和UNDO页的回收。
* IO线程：InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求。IO Thread 主要工作是负责这些IO请求的回调处理。
  * insert buffer thread
  * log thread
  * read thread
  * write thread：读线程数量总是小于写线程
* purge 线程：回收已经使用并分配的undo页
* page cleaner 线程：脏页的刷新，减轻原master thread的工作
#### innodb的内存模型
![内存模型](/img/mysql/bufferpool.png)
基于磁盘的数据库系统通过使用缓冲池技术来提升数据库的整体性能，将数据库文件按页读取到缓存池，借助checkpoint机制刷盘. 缓冲池中缓存的数据页类型有：
* 索引页
* 数据页
* 重做日志缓冲池：undo 页、redo log页
* 插入缓存
* 自适应哈希索引
* InnoDB 存储的锁信息
* 数据字典信息
* 额外缓冲池：提供堆内存

> 特点：数据库中的缓存池是按照（LRU）最近最少使用算法来保留缓冲池中的缓存数据；

#### innodb 关键特性
插入缓冲   
两次写   
自适应哈希   
Innodb存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引   
异步IO   
read ahead方式的读取都是通过AIO完成，脏页的刷新，即磁盘的写入操作则全部由AIO完成。
刷新邻接页   
刷新一个脏页时，innodb存储引擎会检索该页所在区的所有页，如果是脏页，那么一起进行刷新。通过AIO可以将多个IO写入操作合并为一个IO操作，故改工作机制在机械磁盘下有显著的优势。
#### 什么是全文索引，在innodb中如何实现？
#### ACID 的含义及事务隔离级别、引发的问题；
默认可重复读   
使用next-key locking的策略来避免幻读
#### mysql数据库如何避免数据丢失（例如在数据库宕机时）
采用 write ahead log策略，即当事务提交时，先做重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。 
二次写：在对缓冲池的脏页进行刷盘前

#### 什么是mysql的可移植性？
mysql为可移植的数据库。是指几乎在所有系统中都能运行，且基本保证在各平台上的物理体系结构的一致性。

#### 什么是插入式的表存储引擎？
MySQL 插入式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每一个数据库系统本身都需要的，如SQL分析器和优化器等。而存储引擎是底层物理结构的实现，每个存储引擎开发者可以按照自己的意愿进行开发。
-----

# 相关命令：
./mysqld_safe    // 启动数据库，在/bin目录下

mysql --help | grep my.cnf     // mysql数据库实例启动时，查看配置文件的位置，会以读到的最后一个配置文件中的参数为准

show engines    // 查看支持的存储引擎

show engine innodb status //查看缓冲池的使用情况

