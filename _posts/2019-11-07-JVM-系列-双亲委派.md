---
layout: post
title: "JVM 系列 类加载机制"
subtitle: '开启JVM探索新篇章'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - jvm
---

> 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。

## 要点
#### 动态加载
在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

#### 类加载时机
整个生命周期包括：
![存储概览](/img/jvm/jvm1.png)
* 遇到 new、getstatic、putstatic、invokestatic这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这四条指令的最常见的java代码场景是：使用 new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
* 使用 reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
* 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
* 虚拟机启动的时候初始化主类

**当一个类在初始化时，要求其父类全部都已经初始化过了，但是接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正用到了父接口的时候才初始化**

> 子类引用父类的静态字段，不会导致子类初始化
> 通过数组定义来引用类，不会触发此类的初始化，但会加载这个引用类。
> 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

#### 类加载过程
* 加载： 非数组类的加载基于双亲委派。数组类本身不是通过类加载器创建，它是由虚拟机直接创建的。
    * 通过一个类的全限定名来获取定义此类的二进制字节流
    * 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
    * 在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据访问的入口。在 HotSpot中Class对象比较特殊放在了方法区。
* 验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求
* 准备：
* 解析：
* 初始化：

#### 类加载器
对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。

> 动态代理：在reflect.proxy中，就是使用proxyGeneraor.generateProxyClass 来为制定接口生成形式为*Proxy的代理类的二进制字节流。

#### 双亲委派
两种类加载器：
* 启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分。负责将存放在<JAVA>
* 其他类加载器，独立于虚拟机外部，全部继承于ClassLoader