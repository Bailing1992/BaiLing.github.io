---
layout: post
title: "设计模式 系列 代理"
subtitle: '开启 设计模式 探索新篇章'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - Design Patterns 
---

> 代理模式为其他对象提供一种代理以控制对这个对象的访问。静态代理其实就是设计模式中的经典代理模式。动态代理基于经典代理模式，避免了 Proxy 角色的 class 在系统中冗杂的问题



#### 静态代理
![设计模式](/img/pattern/proxy.jpg)
Subject 定义了 RealSubject 和 Proxy 的公共接口，这样就在任何使用 RealSubject 的地方都可以使用 Proxy。

```
abstract class Subject {
	public abstract void Request();
}
```

RealSubject 定义 Proxy 所代表的真实实体。

```
class RealSubject extends Subject {
	@Override
	    public void Request() {
		System.out.println("真实的请求");
	}
}
```

Proxy 保存一个引用使得代理可以访问实体，并提供一个与 Subject 的接口相同的接口，这样代理就可以用来替代实体。

```
class Proxy extends Subject {
	private RealSubject real;
	@Override
	    public void Request() {
		if (null == real) {
			real = new RealSubject();
		}
		real.Request();
	}
}
```

#### 观点
静态代理模式固然在访问无法访问的资源，增强现有的接口业务功能方面有很大的优点，但是大量使用这种静态代理，会使我们系统内的类的规模增大，并且不易维护；并且由于 Proxy 和 RealSubject 的功能本质上是相同的，Proxy 只是起到了中介的作用，这种代理在系统中的存在，导致系统结构比较臃肿和松散。


