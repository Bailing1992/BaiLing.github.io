---
layout: post
title: "JVM 系列 执行引擎"
subtitle: '开启JVM探索新篇章'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - jvm
---


## 编译期与编译器
Java语言的编译期可分为：

* 前端编译器把*.java文件转变为*.class文件的过程（Javac\ECJ）
* 虚拟机的后端运行时编译器（JIT编译器，Hotspot的C1\C2编译器）把字节码转化为机器码的过程
* 静态提前编译器（AOT编译器）直接把*.java文件编译为本地机器代码的过程

Javac这类编译器对代码的运行效率几乎没有任何优化措施，但做了许多针对Java语言编码过程的优化措施来完善程序员的编码风格和提高编码效率。
虚拟机对性能的优化集中在后端的即时编译器中。

#### 前端编译器编译过程
![jvm](/img/jvm/jvm4.png)
* 解析与填充符号表过程
    * 词法分析、语法分析：将源代码的字符流转变为标记（Token）集合，根据Token序列构造抽象语法树的过程。
    * 填出符号表：由一组符号地址和符号信息构成的表格
* 插入式注解处理器的注解处理过程
* 分析与字节码生成过程：对结构上正确的源程序进行上下文有关性质的审查
    * 标注检查：检查的内容包括诸如变量使用前是否已经声明、变量与赋值之间的数据类型是否能够匹配等。
        * 常量折叠：
    * 数据及控制流分析：对程序上下文逻辑更近一步的验证。
    * 解析语法糖：虚拟机在编译阶段将语法糖（泛型、变长参数、自动装箱\拆箱）还原回简单的基础语法结构，这个过程称为解语法糖。
    * 字节码生成

> 在 JDK 1.5，Java语言提供了对注解的支持，注解是在运行期间发挥作用的。    
  在 JDK 1.6，实现了JSR-269规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，可视为编译器的插件，如Lombok。在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理。

> 局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_FIELD ref_info的符号引用，自然就没有访问标志的信息。因此将局部变量声明为final，对运行期没有影响，变量的不变形仅仅由编译器在编译期保障。

#### 范型擦除
![jvm](/img/jvm/jvm3.png)
这段代码是不能被编译的，因为参数List<Integer> 和List<Sting>编译之后都被擦除了，变成一样的原生类型List<E>，擦除操作导致这两个方法的特征签名变得一模一样。

