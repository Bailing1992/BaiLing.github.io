---
layout: post
title: "Mysql 系列 第一讲"
subtitle: '《Mysql 技术内幕：InnoDB存储引擎》'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - mysql
---

> 主要介绍《Mysql 技术内幕：InnoDB存储引擎》第一、二章相关知识点，

# 相关概念：
#### 数据库：
文件的集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合.  
#### 数据库实例：
数据库实例是真正用于操作数据库文件的一个进程.  
#### OLTP（联机事务处理-Online Transaction Processing）：
表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。

OLTP比较常用的设计与优化方式为Cache技术与B-tree索引技术，Cache决定了很多语句不需要从磁盘子系统获得数据，所以，Web cache与Oracle data buffer对OLTP系统是很重要的。另外，在索引使用方面，语句越简单越好，这样执行计划也稳定，而且一定要使用绑定变量，减少语句解析，尽量减少表关联，尽量减少分布式事务，基本不使用分区技术、MV技术、并行技术及位图索引。因为并发量很高，批量更新时要分批快速提交，以避免阻塞的发生。 OLTP 系统是一个数据块变化非常频繁，SQL 语句提交非常频繁的系统。 对于数据块来说，应尽可能让数据块保存在内存当中，对于SQL来说，尽可能使用变量绑定技术来达到SQL重用，减少物理I/O 和重复的SQL 解析，从而极大的改善数据库的性能。

对比OLAP（联机分析处理，亦即DSS决策分析系统）：就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。磁盘子系统的吞吐量则往往取决于磁盘的个数，这个时候，Cache基本是没有效果的，数据库的读写类型基本上是db file scattered read与direct path read/write。应尽量采用个数比较多的磁盘以及比较大的带宽，如4Gb的光纤接口。

*引申：*
数据库与数据仓库的区别；

#### 全文索引： 
MySQL5.6.24上InnoDB引擎也加入了全文索引.

MySQL 5.7.6之前，全文索引只支持英文全文索引，不支持中文全文索引，需要利用分词器把中文段落预处理拆分成单词，然后存入数据库。

MySQL 5.7.6开始，MySQL内置了ngram全文解析器，用来支持中文、日文、韩文分词。

全文索引(也称全文检索)是目前搜索引擎使用的一种关键技术。它能够利用分词技术等多种算法智能分析出文本文字中关键字词的频率及重要性，然后按照一定的算法规则智能地筛选出我们想要的搜索结果。

**注：分词，全文索引以词为基础的，MySQL默认的分词是所有非字母和数字的特殊符号都是分词符。**

*引申：*
倒排索引：全文检索的索引被称为倒排索引，之所以成为倒排索引，是因为将每一个单词作为索引项，根据该索引项查找包含该单词的文本。因此，索引都是单词和唯一记录文本的标示是一对多的关系。将索引单词排序，根据排序后的单词定位包含该单词的文本。

#### MVCC（多版本并发控制）：
解决读-写冲突问题。读不用加锁，通过一定机制生成一个数据请求时间点时的一致性数据快照， 并用这个快照来提供一定级别 （语句级或事务级） 的一致性读取。这样在读操作的时候不需要阻塞写操作，写操作时不需要阻塞读操作。

Mysql的大多数事务型存储引擎实现都不是简单的行级锁，基于并发性能考虑，一般都实现了MVCC多版本并发控制。MVCC是通过保存数据在某个时间点的快照来实现的。不管事务执行多长时间，事务看到的数据都是一致的。

*读操作：*
读操作分成两类：快照读和当前读。

*快照读:*
简单的select操作属于快照读，不加锁。
*当前读:*  
特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。

*MVCC优缺点：*
MVCC在大多数情况下代替了行锁，实现了对读的非阻塞，读不加锁，读写不冲突。缺点是每行记录都需要额外的存储空间，需要做更多的行维护和检查工作。

*数据结构:*  
InnoDB的内部实现中为每一行数据增加了三个隐藏列用于实现MVCC。

*算法策略：*

* select时，InnoDB 会根据两个条件来检查每行记录：  
InnoDB只查找版本(DB_TRX_ID)早于当前事务版本的数据行（行的系统版本号<=事务的系统版本号,这样可以确保数据行要么是在开始之前已经存在了，要么是事务自身插入或修改过的）
行的删除版本号(DB_ROLL_PTR)要么未定义（未更新过），要么大于当前事务版本号（在当前事务开始之后更新的）。这样可以确保事务读取到的行，在事务开始之前未被删除。
* insert时，InnoDB为新插入的每一行保存当前系统版本号作为行版本号  
* delete时，InnoDB为删除的每一行保存当前的系统版本号作为行删除标识。
* update时，InnoDB为插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识. 

> 引申：  
next-key locking的策略：

#### 插入缓存：
作用：解决非聚集索引写性能问题.  
对于非聚集类索引的插入和更新操作，不是每一次都直接插入到索引页中，而是先插入到内存中。具体做法是：如果该索引页在缓冲池中，直接插入；否则，先将其放入插入缓冲区中，再以一定的频率和索引页合并，这时，就可以将同一个索引页中的多个插入合并到一个IO操作中，大大提高写性能。

聚簇索引和非聚集索引的区别：   
InnoDB是基于主键的聚簇索引。通常应用程序中行纪录的插入顺序是按照主键递增的顺序进行插入的。因此，插入聚集索引一般是顺序的，不需要磁盘的随机读写。   
对于非聚簇索引的叶子节点的插入不再是顺序的了（InnoDB非聚簇索引的叶子节点的值不再是行，而是指向了主键索引），这是就需要离散的访问非聚簇索引页，由于随机读取的存在而导致了插入操作的性能下降。 

聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致.  
聚集索引表记录的排列顺序与索引的排列顺序一致（查询速度快 修改速度较慢).  
非聚集索引指定了表中记录的逻辑顺序，但记录的物理顺序和索引的顺序不一致

使用条件：   
辅助索引 非唯一索引

#### LRU算法：
作用：缓存的替换策略.  
缓冲池采用the least recently used（LRU）算法的变体，将缓冲池作为列表进行管理。

算法原理:   
当需要空间将新页面缓存到缓冲池的时候，最近最少使用的页面将被释放出去，并将新的页面加入列表的中间。这个中间点插入的策略将列表分为两个子列表：

1. 头部是存放最近访问过的新（官网给出一个“ young ”来修饰）页面的子列表
2. 尾部是存放那些最近访问较少的旧页面的子列表.  
   该算法将保留 new sublist（也就是结构图中头部）中大量被查询使用的页面。而old sublist 里面较少被使用的页面作为被释放的候选项.  
相关参数：   
    innodb_old_blocks_time  // 移动时间.  
    innodb_old_blocks_pct  // 旧链表与新链表的长度.  

#### checkpoint技术
数据经过更新或者删除之后，数据页变为脏页，需要刷回磁盘，在事务提交时，先写重做日志，再修改页，再在合适的时机刷回磁盘。这样即使宕机，也可以通过重做日志来恢复数据。（这即为ACID的Durability）。这个时机就是Checkpoint技术。这个技术解决了如下问题：

缩短数据库恢复时间.  
缓冲池不够用时，将脏页刷新到磁盘.  
重做日志不可用时，刷新脏页.  
   当数据库宕机之后，只需对checkpoint后的重做日志进行恢复，就大大缩短了恢复时间。当一部分重做日志不再需要的时候，这部分就可以被覆盖重用，在复写前，会强制产生checkpoint，将缓冲池的脏页刷新到当前重做日志的位置.  
   对于InnoDB而言，是通过LSN来标记版本的，LSN是8字节的数字，单位是字节，每个页有LSN，重做日志也有LSN.  
   Checkpoint的发生时间和条件，以及脏页的选择都非常复杂。InnoDB根据不同情况将Checkpoint分为两种：

* Sharp Checkpoint
* Fuzzy Checkpoint.  
Sharp Checkpoint在数据库关闭时，将所有的脏页都刷新回磁盘。在运行时是不可能这么做的，所以采用Fuzzy Checkpoint，有这么几种情况会触发:

* Master Thread Checkpoint
* FLUSH_LRU_LIST Checkpoint
* Async/Sync Flush Checkpoint
* Dirty Page too much Checkpoint
#### 两次写
*背景：*.  
InnoDB 中有记录（Row）被更新时，先将其在 Buffer Pool 中的 page 更新，并将这次更新记录到 Redo Log file 中，这时候 Buffer Pool 中的该 page 就是被标记为 Dirty。在适当的时候（Buffer Pool 不够、Redo 不够，系统闲置等），这些 Dirty Page 会被 Checkpoint 刷新到磁盘进行持久化操作。

*重点：*.   
InnoDB 的 Page Size 是 16KB，其数据校验也是针对这 16KB 来计算的，将数据写入到磁盘是以 Page 为单位进行操作的，而文件系统是以 4k 为单位写入，磁盘 IO 的最小单位是 512B，因此并不能保证数据页的写入就是原子性的.  
为什么不能使用redo log 来进行恢复呢？答案是只能恢复校验完整（还没写）的页，不能恢复已损坏的页。比如某次 checkpoint 要刷入 4 个数据页，其中第一页写了 2KB，后三页还未写。那么根据 redo log 可以恢复后三页，但已经写了 2KB 的页没法恢复，因为没法知道在宕机前第一页到底写了多少。


*实现策略：*.  
  double write 由两部分组成，一部分是内存中的 doublewrite buffer，大小为 2MB，另一部分是物理磁盘上共享表空间中连续的 128 个页，即 2 个区，大小同样为 2MB。在对缓冲池的脏页进行刷新时，并不直接写磁盘，而是会通过 memcpy 函数将脏页先复制到内存中的 doublewrite buffer，之后通过 doublewrite buffer 再分两次，每次 1MB 顺序地写入共享表空间的物理磁盘上，然后马上调用 fsync 函数，同步磁盘。在这个过程中，因为 doublewrite 页是连续的，因此这个过程是顺序写的，开销不是很大。

当宕机发生时，有那么几种情况：

1. 磁盘还未写，此时可以通过 redo log 恢复；
2. 磁盘正在进行从内存到共享表空间的写，此时数据文件中的页还没开始被写入，因此也同样可以通过 redo log 恢复；
3. 磁盘正在写数据文件，此时共享表空间已经写完，可以从共享表空间拷贝页的副本到数据文件实现恢复。

#### 伙伴算法：
#### 哈夫曼编码

-----

# 相关问题
#### MySQL的特点
单进程多线程架构
插件式存储引擎
开源
#### MySQL 体系结构及各个模块的作用（sql语句的执行流程）
连接池组建
管理服务和工具组件
SQL接口组件
分析器组件
优化器组件
缓冲组件
插件式存储引擎
物理文件
#### Innodb 存储引擎的特点
完整支持ACID事物，实现SQL标准的4中隔离级别
行锁设计
支持外键
采用聚集的方式（每张表都按主键的顺序存放）
支持非锁定读（默认读取操作不会产生锁）
支持MVCC（多版本并发控制）
支持全文索引
支持插入缓存
支持二次写
支持自适应哈希索引
支持预读
#### MySQL中myisam与innodb的不同之处
不支持事务
不支持表锁
不支持全文索引
默认支持256T的单表数据（5.0）
五、innodb的线程模型；
七个后台线程：

4个IO线程：insert buffer thread、log thread、read thread、write thread
1个master线程（最高优先级）：
主循环
每秒钟的操作
重做日志缓冲刷新到磁盘中重做日志文件中，即使事务还没有提交
合并插入缓冲：只有在IO压力小的情况下执行。
刷盘：至多刷新100个缓冲池中的脏数据页到磁盘
每10秒的操作
刷新100个脏页到磁盘
后台循环
刷新循环
暂停循环
1个锁监控线程：
1个错误监控线程：
特点：

单进程多线程架构
master thread线程几乎实现了所有的功能

#### innodb数据缓冲的策略；
存储引擎：

缓冲池： 将数据库文件按页读取到缓存池；
索引页
数据页
重做日志缓冲池：
额外缓冲池：提供堆内存
特点：


按照（LRU）最近最少使用算法来保留缓冲池中的缓存数据；



#### innodb 关键特性
插入缓冲   
两次写   
自适应哈希   
Innodb存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引   
异步IO   
read ahead方式的读取都是通过AIO完成，脏页的刷新，即磁盘的写入操作则全部由AIO完成。
刷新邻接页   
刷新一个脏页时，innodb存储引擎会检索该页所在区的所有页，如果是脏页，那么一起进行刷新。通过AIO可以将多个IO写入操作合并为一个IO操作，故改工作机制在机械磁盘下有显著的优势。
#### 什么是全文索引，在innodb中如何实现？
#### ACID的含义及事务隔离级别、引发的问题；
默认可重复读   
使用next-key locking的策略来避免幻读
#### mysql数据库如何避免数据丢失（例如在数据库宕机时）
采用 write ahead log策略，即当事务提交时，先做重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。 
二次写：在对缓冲池的脏页进行刷盘前

-----

# 相关命令：
show engines    // 查看支持的存储引擎

show engine innodb status //查看缓冲池的使用情况

