---
layout: post
title: "MySQL 系列 锁"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 锁是数据库系统区别于文件系统的一个关键特性

## 概念
#### 锁
锁机制用于管理对共享资源的并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完成性和一致性。InnoDB存储引擎会在行级别上对表数据上锁。行级锁没有相关额外的开销，并可以同时得到并发行和一致性。
![存储概览](/img/mysql/lock.png)

1. latch 闩锁（轻量级的锁）：其要求锁定的时间必须非常短，若持续的时间长，则应用的性能会非常差。用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。可分为：
  * mutex（互斥锁）
  * rwlock(读写锁)

2. lock 的对象是事务，用来锁定的是数据库中的对象，如表、页、行。一般lock的对象仅在事务commit或rollback后进行释放（不用事务隔离级别释放的时间可能不同）。有死锁机制

#### 锁的类型
InnoDB 存储引擎实现了两种标准的行级锁：
1. 共享锁（S Lock）：允许事务读一行数据。 如果一个事务T1已经获得了行r的共享锁，那么另外的事务T2可以立即获得行r的共享锁。因为读取并没有改变行r的数据，称这种情况为锁兼容。
2. 排他锁（X Lock）：允许事务删除或更新一行数据。 若事务T3想获取行r的排它锁，则其必须等待其他事务T1、T2释放行r上的共享锁，这种情况称为锁不兼容。

X锁与任何锁都不兼容，S锁仅与S锁兼容。
#### 锁粒度
Innodb 支持多粒度锁定，这种锁定允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB存储引擎支持一种额外的锁方式-意向锁。
**InnoDB 存储引擎支持意向锁设计比较简单，其意向锁即为表级别的锁。意向锁是一种不与行级锁冲突表级锁**。其支持两种意向锁：        
* 意向共享锁（IS LOCK）事务想要获取一张表中某几行的共享锁
* 意向排它锁（IX LOCK）事务想要获取一张表中某几行的排它锁。

> 意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。      
意向锁是由存储引擎维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB会先获取该数据行所在在数据表对应的意向锁。         
若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。

![存储概览](/img/mysql/Ilock.png)

InnoDB 
#### 一致性非锁定读
InnoDB 通过行多版本控制的方式来读取当前执行时间数据库中行的数据。这是默认的读取方式，即读取不会占用或等待表上的锁。     
**在不同的事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都有采用非锁定的一致性读：**    
> 在事务隔离级别read committed， innodb 存储引擎使用非锁定的一致性读。对于快照数据，非一致性读总是读取被锁定行的最新一个快照数据。

> 对于read ocmmitted 事务隔离级别，它总是读取行的最新版本。如果行被锁定了，则读取该行版本的最新一个快照。其违反了ACID中的I隔离性
 
> 在事务隔离级别repeatable read，对于快照数据，非一致性读总是读取事务开始时的行版本数据。

![存储概览](/img/mysql/snapshot.png)
快照数据：行的之前版本数据，该实现是通过undo段来实现。读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。


#### 一致性锁定读
显示的对数据库读取操作进行加锁以保证数据逻辑的一致性。
* select ... for update:对读取的行记录加X锁
* select ... lock in share mode: 对读取的行加S锁。

#### 外键和锁
对于外键值的插入和更新，首先需要查询父表中的记录，即select父表。但是对于父表的select操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，所以使用的是select ... lock in share mode 方式，即主动对父表加一个s锁，如果这时父表已经这样加X锁，子表上的操作会被阻塞。
> 外键： 只要用于引用完整性的约束检查。在innodb存储引擎中，对于一个外键列，如果没有显示的对这个列加索引，会自动的对其加一个索引，这样能够避免表锁。

锁是在索引上加的

#### 锁算法
3种行锁算法：
* record lock: 单个行记录上的锁
* Gap lock: 间隙锁，锁定一个范围，但不包括记录本身。
* Next-key lock:锁定一个范围，并且锁定记录本身。

record lock 总是会去锁定索引记录。

Innodb对于行的查询采用next-key lock锁定算法。采用next-key lock锁定技术称为next-key locking，其设计的目的是为了解决幻读。
当查询的索引是唯一索引时，innodb储存引擎会对next-key lock进行优化,将其降级为record lock。    
对于辅助索引，加next-key lock ,除此之外，还会对辅助索引的下一个键值加上gap lock.

Gap锁的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。

#### 锁问题
用过锁定机制可以实现事务的隔离级别的要求

###### 脏读
> 脏数据是指事务对缓冲池中行记录的修改，并且还没有被提高。如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，则显然违反了数据库的隔离型。

###### 不可重复读（幻读）
> 在一个事务中，多次读取同一数据集合。

不可重复度和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了数据库事务一致性的要求。

在innodb中，通过使用next-key lock算法来避免不可重读问题。 对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住那些索引覆盖的范围（gap）,因此在这个范围内插入都是不被允许的。

###### 丢失更新
一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。     
*在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题*    
要避免丢失更新操作，需要让事务的操作变成串行化，而不是并行操作

#### 阻塞
因为不同锁之间的兼容性问题，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它锁占用的资源，这就是阻塞。

#### 死锁
死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。
处理方法：
* 超时：即当两个事务相互等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。
* wait for grap 等待图： 更为主动的进行死锁检查。在每个事务请求锁并发生等待时都会判断是否存在回路，如存在则有死锁。

*wait for grap 死锁检测采用深度优先的算法 实现*

**innobd是不会回滚大部分的错误异常，但死锁除外**

#### 锁升级
将当前锁的粒度降低。
innodb不存在锁升级的问题。**因为其不是根据每个记录来产生行锁的，相关，其根据每个事务访问的每个页对锁进行管理的，采用了位图的方式.**因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。

## 问题
#### 如何在应用层面实现唯一性检查
可以通过innodb存储引擎的next-key locking机制在应用层面实现唯一性的检查。
```
 select * from table where col = XXXX lock in share mode

```
如果用户通过索引查询一个值，并对该行加上一个SLock,即使查询的值不存在，其锁定的也是一个范围，因此如没有返回任何行，那么新插入的值一定是唯一的。

## 命令：
