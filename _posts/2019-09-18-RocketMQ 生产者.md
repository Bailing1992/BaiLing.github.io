---
layout: post
title: "RocketMQ 系列 生产者"
subtitle: '刨析rocketMQ的底层实现'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - rocketMQ
---

## 概念
#### Message


## 问题
#### 消息发送流程？


#### rocketMq通信协议是什么？
![存储概览](/img/rocketmq/protocol.jpg)
RocketMQ 设计了自己的一个通信协议，用于消息内容和二进制格式之间的转换：
1. length：4 字节整数，二三四部分长度总和；
2. header length：4字节整数，第三部分header data长度；
   * 最高8为存储header data的协议
   * 底24位为数据长度 
3. header data：存放Json序列化的数据；
4. body data：应用自定义二进制序列化的数据。

###### 消息的编码过程：
消息的编码是在 RemotingCommand 中 encode 方法中完成的：
```
public ByteBuffer encode() {
    // 1> header length size
    int length = 4;
    // 2> header data length
    byte[] headerData = this.headerEncode();
    length += headerData.length;
    // 3> body data length
    if (this.body != null) {
        length += body.length;
    }
    ByteBuffer result = ByteBuffer.allocate(4 + length);
    // 1.先放入消息的总大小
    result.putInt(length);
    // 2.再放入头部的长度
    result.put(markProtocolType(headerData.length, serializeTypeCurrentRPC));
    // 3.接着放入头部数据
    result.put(headerData);
    // 4.最后放入消息体的数据
    if (this.body != null) {
        result.put(this.body);
    }
    result.flip();
    return result;
}

```

###### 消息的解码过程：
消息的解码是在类 RemotingCommand 中 decode方法中完成的：
```
public static RemotingCommand decode(final ByteBuffer byteBuffer) {
    int length = byteBuffer.limit();// 获取byteBuffer的总长度
    int oriHeaderLen = byteBuffer.getInt();// 1.获取前4个字节，组装int类型，该长度为总长度 图中 length
    int headerLength = getHeaderLength(oriHeaderLen);// length & 0xFFFFFF 获取消息头的长度，与运算，编码时候的长度即为24位
    byte[] headerData = new byte[headerLength];// 保存header data
    byteBuffer.get(headerData);// 2.从缓冲区中读取headerLength个字节的数据，这个数据就是报文头部的数据
    RemotingCommand cmd = headerDecode(headerData, getProtocolType(oriHeaderLen));
    int bodyLength = length - 4 - headerLength;// 报文体的数据，减去了第二、三部分的长度
    byte[] bodyData = null;
    if (bodyLength > 0) {
        bodyData = new byte[bodyLength];
        byteBuffer.get(bodyData);// 获取消息体的数据
    }
    cmd.body = bodyData;
    return cmd;
}
```

#### rocketMQ 如何处理半包问题？
通过在消息头定义长度字段来标识消息总长度, Netty提供了相应的解码器：LengthFieldBasedFrameDecoder
> 大多数协议（私有或公有），协议头中会携带长度字段，用于标识消息体或者整包消息的长度，例如SMPP、HTTP协议等。由于基于长度解码需求的通用性，Netty提供了LengthFieldBasedFrameDecoder，自动屏蔽TCP底层的拆包和粘包问题，只需要传入正确的参数，即可轻松解决"读半包"问题。
