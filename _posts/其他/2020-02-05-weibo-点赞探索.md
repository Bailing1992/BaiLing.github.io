---
layout: post
title: "Dubbo 系列 扩展组件"
author: "lichao"
header-img: "img/netty/host.png"
catalog: true
tags:
  - other
---



## 点赞
```
  static final String USER_KEY = "user_like_record_";
    static final String WEiBO_KEY =  "weibo_like_record_";
    static final Long ONE_WEEK = 24*3600*7l;
    public void like(int uid, int weiboId) throws RuntimeException {
        if(isLiked(uid,weiboId)){
            try {
                sendLikeMassage(userId, weiboId);
            }catch (Exception e){
                throw new RuntimeException("服务异常");
            }
            redisCluster.addFixedTimeList(WEiBO_KEY + weiboId, uid);

        }
    }



    void sendLikeMassage(Integer userId, Integer weiboId) throws Exception{
        Massage massage =new Message(userId,weiboId);
        sendAsync(message, Optional.empty(), Optional.empty());
    }

```
## 查询赞
```
    public boolean isLiked(int uid, int weiboId){
        // 微博最近7天 点赞记录
        WeiBo weiBo = redisCluster.getWeibo(weiboId);
        List<Integer> userIds = redisCluster.getFixedTimeList(WEiBO_KEY + weiboId, ONE_WEEK);
        if(userIds.contains(uid)){
            return true;
        }else{
            if(weiBo.createTime() > System.currentTimeMillis() - ONE_WEEK) {
                return false;
            }
        }
        LikeRecord likeRecord = likeRecordService.select(weiboId, uid);
        if(likeRecord == null){
            return false;
        }
        return true;
    }

```

## 点赞数据存储

```
CREATE TABLE `like_record` (
  `id` INT NOT NULL,
  `weibo_id` VARCHAR(45) NULL,
  `user_id` VARCHAR(45) NULL,
  `create_time` VARCHAR(45) NULL,
  `create_by` VARCHAR(45) NULL,
  PRIMARY KEY (`id`),
  INDEX `idx_weibo_user` (`weibo_id` ASC, `user_id` ASC),
  UNIQUE INDEX `idx_user_weibo` (`user_id` ASC, `weibo_id` ASC));
```

# 数据库分表分库
## 分表方案
对于一亿甚至几亿以下的数据规模来说，拆表能够解决很多问题。

* 为了使同一个微博下的点赞记录在同一张表上
 weibo_id & 1023 

 问题： 扩展性不好，不好加表，数据一旦满了，加起来很郁闷。

* 按微博的发布时间进行分段拆表，满了就建新表

问题： 冷热不均，最近的 weibo 肯定是被访问最频繁的，而老的库又基本没有访问。 可以通过冷热库混合部署的方案来缓解，但是部署和维护的成本非常大。

#### 加缓存
上 Cache( Redis), 访问时先访问Cache，不命中时再访问 mysql。
参考Mysql innodb缓冲的设计思想。

* 微博的最近点赞列表，可以查询点赞列表

* 用户的最近点赞列表。