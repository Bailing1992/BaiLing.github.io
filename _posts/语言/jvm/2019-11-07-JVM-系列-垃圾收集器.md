---
layout: post
title: "JVM 系列 垃圾收集器"
subtitle: '开启JVM探索新篇章'
author: "lichao"
header-img: "img/post-bg-digital-native.jpg"
catalog: true
tags:
  - jvm
---
> 垃圾收集器的不断更新，只为消除或减少工作线程因内存回收而导致的停顿。

基于 JDK 1.7Update 14 之后的 hotspot 虚拟机包含的所有垃圾回收器：
![存储概览](/img/jvm/18.png)

## 原理
#### GC调优目标
大多数情况下对 Java 程序进行 GC 调优, 主要关注两个目标：响应速度、吞吐量

* 响应速度(Responsiveness)      
响应速度指程序或系统对一个请求的响应有多迅速。比如，用户订单查询响应时间，对响应速度要求很高的系统，较大的停顿时间是不可接受的。调优的重点是在短的时间内快速响应

* 吞吐量(Throughput)     
吞吐量关注在一个特定时间段内应用系统的最大工作量，例如每小时批处理系统能完成的任务数量，在吞吐量方面优化的系统，较长的GC停顿时间也是可以接受的，因为高吞吐量应用更关心的是如何尽可能快地完成整个任务，不考虑快速响应用户请求

GC 调优中，GC 导致的应用暂停时间影响系统响应速度，GC 处理线程的 CPU 使用率影响系统吞吐量

#### GC事件分类

根据垃圾收集回收的区域不同，垃圾收集主要通常分为 Young GC、Old GC、Full GC、Mixed GC:

1. Young GC

新生代内存的垃圾收集事件称为Young GC(又称Minor GC)，当JVM无法为新对象分配在新生代内存空间时总会触发 Young GC，比如 Eden 区占满时。新对象分配频率越高, Young GC 的频率就越高

Young GC 每次都会引起全线停顿(Stop-The-World)，暂停所有的应用线程，停顿时间相对老年代GC的造成的停顿，几乎可以忽略不计
2. Old GC 、Full GC、Mixed GC

Old GC，只清理老年代空间的GC事件，只有CMS的并发收集是这个模式

Full GC，清理整个堆的GC事件，包括新生代、老年代、元空间等

Mixed GC，清理整个新生代以及部分老年代的GC，只有G1有这个模式

Java 提供的自动内存管理，可以归结为解决了对象的内存分配和回收的问题，前面已经介绍了内存回收，下面介绍几条最普遍的内存分配策略

#### 内存分配策略

Java 提供的自动内存管理，可以归结为解决了对象的内存分配和回收的问题，前面已经介绍了内存回收，下面介绍几条最普遍的内存分配策略

* 对象优先在 Eden 区分配     
大多数情况下，对象在先新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Young GC

* 大对象直接进入老年代     
JVM提供了一个对象大小阈值参数(-XX:PretenureSizeThreshold，默认值为0，代表不管多大都是先在Eden中分配内存)，大于参数设置的阈值值的对象直接在老年代分配，这样可以避免对象在Eden及两个Survivor直接发生大内存复制

* 长期存活的对象将进入老年代      
对象每经历一次垃圾回收，且没被回收掉，它的年龄就增加1，大于年龄阈值参数(-XX:MaxTenuringThreshold，默认15)的对象，将晋升到老年代中

* 空间分配担保     
当进行Young GC之前，JVM需要预估：老年代是否能够容纳Young GC后新生代晋升到老年代的存活对象，以确定是否需要提前触发GC回收老年代空间，基于空间分配担保策略来计算：

#### 分配担保策略
continueSize：老年代最大可用连续空间

![存储概览](/img/jvm/33.png)

Young GC 之后如果成功(Young GC后晋升对象能放入老年代)，则代表担保成功，不用再进行 Full GC，提高性能；如果失败，则会出现 “promotion failed” 错误，代表担保失败，需要进行 Full GC

动态年龄判定      
新生代对象的年龄可能没达到阈值(MaxTenuringThreshold参数指定)就晋升老年代，如果Young GC之后，新生代存活对象达到相同年龄所有对象大小的总和大于任一Survivor空间(S0 或 S1总空间)的一半，此时S0或者S1区即将容纳不了存活的新生代对象，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄

另外，如果 Young GC 后 S0 或 S1 区不足以容纳：未达到晋升老年代条件的新生代存活对象，会导致这些存活对象直接进入老年代，需要尽量避免

## Serial ( Client模式 )
>  关键词：新生代，client模式，单线程

![存储概览](/img/jvm/19.png)
Serial 收集器是最基本、历史最久的收集器，曾是新生代收集的唯一选择。它是单线程的，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且它在收集的时候，必须暂停其它所有的工作线程，直到它结束，即“Stop the World”。尽管如此，它仍然是虚拟机运行在 client 模式下的默认新生代收集器：简单而高效（与其他收集器的单个线程相比，因为没有线程切换的开销等）。
## ParNew

>  关键词：新生代，server模式

![存储概览](/img/jvm/20.png)
ParNew 收集器 是 Serial 收集器的多线程版本，除了使用了多线程之外，其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同Serial收集器一样。 是许多运行在 Server 模式下的 JVM 中首选的新生代收集器，其中一个很重还要的原因就是除了Serial之外，只有它能和老年代的CMS收集器配合工作。

## CMS
>  关键词：老年代，server 模式

![存储概览](/img/jvm/21.png)
> 基于 标记-清除 算法
CMS(Concurrent Mark Sweep 并发标记收集器) 收集器是一种以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验好。基于“标记清除”算法，并发收集、低停顿，运作过程复杂，分 4 步：
1. 初始标记：仅仅标记GC Roots能直接关联到的对象，速度快，但是需要“Stop The World”
2. 并发标记：就是进行追踪引用链的过程，可以和用户线程并发执行。
3. 重新标记：修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要“Stop The World”
4. 并发清除：清除标记为可以回收对象，可以和用户线程并发执行
由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以总体上来看，CMS 收集器的内存回收过程和用户线程是并发执行的。

> 新生代的规模一般都比老年代要小许多，新生代的回收也比老年代要频繁很多。收集器中的新生代与老年代之间的对象引用是使用 Remembered Set 来避免全堆扫描的

#### 缺点
1. CMS 收集器对 CPU 资源非常敏感：CMS 默认启动的收集线程数不少于 25% 的 CPU 资源，并且随着 CPU 数量的增加而下降
2. CMS 收集器无法处理浮动垃圾。在垃圾回收时，需要预留有足够的内存空间给用户线程使用。在 JDK 1.5 的默认配置下，CMS 收集器在老年代使用了 68% 的空间后就被激活。在 JDK 1.6 中，CMS 收集器的启动阈值已经提升到了 92%。
3. CMS 是一款基于“标记-清除”算法实现的收集器，会有大量空间碎片产生。

> 空间碎片过多时，将会给大对象分配带来很大麻烦。CMS会择机进行内存碎片的合并整理

## G1

> 关键词：整个堆，服务端，标记-整理算法 及 标记-复制算法，化整为零的思想

G1（Garbage-First）是JDK7-u4才正式推出商用的收集器。G1是面向服务端应用的垃圾收集器。它的使命是未来可以替换掉CMS收集器。

G1 将整个 Java堆 划分为多个大小相等的独立区域 region，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分region（不需要连续）的集合。

## 参考文献
https://juejin.im/post/5b6b986c6fb9a04fd1603f4a