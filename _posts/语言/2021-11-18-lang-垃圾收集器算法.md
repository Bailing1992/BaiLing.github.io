---
layout: post
title: "Lang 系列 垃圾收集算法"
subtitle: '介绍常见的 GC 算法'
author: "lichao"
header-img: "img/post/bg/post-bg-digital-native.jpg"
catalog: true
tags:
  - lang
---

## 引用计数法
根据对象自身的引用计数来回收，当引用计数归零时进行回收，但是计数频繁更新会带来更多开销，且无法解决循环引用的问题。

- 优点：简单直接，回收速度快
- 缺点：需要额外的空间存放计数，无法处理循环引用的情况；

## 标记清除算法
首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。
![标记清除算法](/img/post/lang/标记清除算法.png)



- 优点: 简单直接，速度快，适合可回收对象不多的场景
- 缺点:
  1. 效率问题：标记和清除两个过程的效率都不高。
  2. 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

> 后续的收集算法都是基于这种思路并对其不足进行改进而得到的。

## 标记复制算法
标记复制法将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
![标记复制算法](/img/post/lang/标记复制算法.png)

- 优点: 解决了内存碎片的问题，每次清除针对的都是整块内存，但是因为移动对象需要耗费时间，效率低于标记清除法；
- 缺点: 有部分内存总是利用不到，资源浪费，移动存活对象比较耗时，并且如果存活对象较多的时候，需要担保机制确保复制区有足够的空间可完成复制；

## 标记整理算法
标记过程同标记清除法，结束后将存活对象压缩至一端，然后清除边界外的内容。
![标记整理算法](/img/post/lang/标记整理算法.png)

- 优点：解决了内存碎片的问题，也不像标记复制法那样需要担保机制，存活对象较多的场景也使适用；
- 缺点：性能低，因为在移动对象的时候不仅需要移动对象还要维护对象的引用地址，可能需要对内存经过几次扫描才能完成；

> 适用于老年代中，存在大量的存活对象需要复制。

## 分代收集算法
现代的垃圾收集器基本都是采用分代收集算法，其主要思想: 将对象根据存活时间的长短进行分类，存活时间小于某个值的为年轻代，存活时间大于某个值的为老年代，永远不会参与回收的对象为永久代。并根据分代假设（如果一个对象存活时间不长则倾向于被回收，如果一个对象已经存活很长时间则倾向于存活更长时间）对对象进行回收。针对不同存活周期、不同大小的对象采取不同的垃圾回收策略
![分代垃圾回收算法](/img/post/lang/分代垃圾回收算法.png)

新生代（Young Generation）: 又叫年轻代，大多数对象在新生代中被创建，很多对象的生命周期很短。每次新生代的垃圾回收（又称Young GC、Minor GC、YGC）后只有少量对象存活，所以使用**标记复制算法**，只需少量的复制操作成本就可以完成回收。新生代内又分三个区：一个 Eden 区，两个 Survivor 区(S0、S1，又称 From Survivor、To Survivor)，大部分对象在 Eden 区中生成。当 Eden 区满时，还存活的对象将被复制到两个 Survivor 区（中的一个）。当这个 Survivor 区满时，此区的存活且不满足晋升到老年代条件的对象将被复制到另外一个 Survivor 区。对象每经历一次复制，年龄加 1，达到晋升年龄阈值后，转移到老年代。

老年代（Old Generation）: 在新生代中经历了 N 次垃圾回收后仍然存活的对象，就会被放到老年代，该区域中对象存活率高。老年代的垃圾回收通常使用“标记-整理”算法


> Hotspot 虚拟机默认的 eden 和 servivor 的大小比例是 8:1，也就是每次新生代中可用内存空间为整个新生代容量的 90%。当 servitor 空间不够用时，需要依赖其他内存（老年代）进行担保。