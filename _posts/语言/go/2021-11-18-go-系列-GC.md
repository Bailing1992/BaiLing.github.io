---
layout: post
title: "Go 系列 GC"
author: "lichao"
header-img: "img/post/bg/post-bg-ngon-ngu-golang.jpg"
catalog: true
tags:
  - go
---


## 背景
GC(Garbage Collection 垃圾回收)，是一种自动管理内存的机制。传统的编程语言（C/C++）中，释放无用变量内存空间是程序员手动释放，存在内存泄漏或者释放不该释放内存等问题。为了解决这个问题，后续的语言（java\python\php\golang等）都引入了语言层面的自动内存管理，语言使用者无需对内存进行手动释放，内存释放由虚拟机（virtual machine）或者运行时（runtime）来对不再使用的内存资源进行自动回收。

#### 发展史
- [go1.1](https://golang.org/doc/go1.1#performance)，提高效率和垃圾回收精确度。
- [go1.3](https://golang.org/doc/go1.3#garbage_collector)，提高了垃圾回收的精确度。
- [go1.4](https://golang.org/doc/go1.4#runtime)，之前版本的 runtime 大部分是使用 C 写的，这个版本大量使用 Go 进行了重写，让 GC 有了扫描 stack 的能力，进一步提高了垃圾回收的精确度。
- [go1.5](https://golang.org/doc/go1.5#gc)，目标是降低 GC 延迟，**采用了并发标记和并发清除，三色标记，write barrier，以及实现了更好的回收器调度**，[设计文档1](https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4/edit)，[文档2](https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit#)，以及2015 版的[Go talk](https://talks.golang.org/2015/go-gc.pdf)。
- [go1.6](https://golang.org/doc/go1.6)，小优化，当程序使用大量内存时，GC 暂停时间有所降低。
- [go1.7](https://golang.org/doc/go1.7)，小优化，当程序有大量空闲 goroutine，stack 大小波动比较大时，GC 暂停时间有显著降低。
- [go1.8](https://golang.org/doc/go1.8)，write barrier 切换到 hybrid write barrier，以消除 STW 中的 re-scan，把 STW 的最差情况降低到 50us，[设计文档](https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md)。
- [go1.9](https://golang.org/doc/go1.9)，提升指标比较多，（1）过去 ```runtime.GC```, ```debug.SetGCPercent```, 和 ```debug.FreeOSMemory```都不能触发并发 GC，他们触发的 GC 都是阻塞的，go1.9 可以了，变成了在垃圾回收之前只阻塞调用 GC 的 goroutine。（2）```debug.SetGCPercent```只在有必要的情况下才会触发GC。
- [go.1.10](https://golang.org/doc/go1.10)，小优化，加速了GC，程序应当运行更快一点点。
- [go1.12](https://golang.org/doc/go1.12)，显著提高了堆内存存在大碎片情况下的 sweeping 性能，能够降低 GC 后立即分配内存的延迟。
- [go1.13](https://golang.org/doc/go1.13)，着手解决向操作系统归还内存的，提出了新的 Scavenger
- [go1.14](https://golang.org/doc/go1.14)，替代了仅存活了一个版本的 Scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题

**主要版本优化：**
- 1.5 版本以及以后版本的 GC 主要分为四个阶段，其中标记和清理都是并发执行的，但是标记阶段的前后需要使用 STW 来做 GC 的准备工作和栈的 rescan（这也是1.8的优化点）。
- 1.8 版本引入混合屏障，最小化第一次 STW，写入屏障和删除屏障各有优缺点，Dijkstra 写入写屏障在标记开始时无需 STW，可直接开始，并发进行，但结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；Yuasa 的删除写屏障则需要在 GC 开始时 STW 扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象，但结束时无需 STW。Go1.8 版本引入的混合写屏障结合了 Yuasa 的删除写屏障和 Dijkstra 的写入写屏障，结合了两者的优点
![GC算法环节](/img/go/GC算法环节.png)

## GC算法
