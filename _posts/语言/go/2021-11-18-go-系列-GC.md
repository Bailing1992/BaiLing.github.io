---
layout: post
title: "Go 系列 GC"
author: "lichao"
header-img: "img/post/bg/post-bg-ngon-ngu-golang.jpg"
catalog: true
tags:
  - go
---


## 背景
GC(Garbage Collection 垃圾回收)，是一种自动管理内存的机制。传统的编程语言（C/C++）中，释放无用变量内存空间是程序员手动释放，存在内存泄漏或者释放不该释放内存等问题。为了解决这个问题，后续的语言（java\python\php\golang等）都引入了语言层面的自动内存管理，语言使用者无需对内存进行手动释放，内存释放由虚拟机（virtual machine）或者运行时（runtime）来对不再使用的内存资源进行自动回收。

#### 发展史
- [go1.1](https://golang.org/doc/go1.1#performance)，提高效率和垃圾回收精确度。
- [go1.3](https://golang.org/doc/go1.3#garbage_collector)，提高了垃圾回收的精确度。
- [go1.4](https://golang.org/doc/go1.4#runtime)，之前版本的 runtime 大部分是使用 C 写的，这个版本大量使用 Go 进行了重写，让 GC 有了扫描 stack 的能力，进一步提高了垃圾回收的精确度。
- [go1.5](https://golang.org/doc/go1.5#gc)，目标是降低 GC 延迟，**采用了并发标记和并发清除，三色标记，write barrier，以及实现了更好的回收器调度**，[设计文档1](https://docs.google.com/document/d/16Y4IsnNRCN43Mx0NZc5YXZLovrHvvLhK_h0KN8woTO4/edit)，[文档2](https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit#)，以及2015 版的[Go talk](https://talks.golang.org/2015/go-gc.pdf)。
- [go1.6](https://golang.org/doc/go1.6)，小优化，当程序使用大量内存时，GC 暂停时间有所降低。
- [go1.7](https://golang.org/doc/go1.7)，小优化，当程序有大量空闲 goroutine，stack 大小波动比较大时，GC 暂停时间有显著降低。
- [go1.8](https://golang.org/doc/go1.8)，write barrier 切换到 hybrid write barrier，以消除 STW 中的 re-scan，把 STW 的最差情况降低到 50us，[设计文档](https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md)。
- [go1.9](https://golang.org/doc/go1.9)，提升指标比较多，（1）过去 ```runtime.GC```, ```debug.SetGCPercent```, 和 ```debug.FreeOSMemory```都不能触发并发 GC，他们触发的 GC 都是阻塞的，go1.9 可以了，变成了在垃圾回收之前只阻塞调用 GC 的 goroutine。（2）```debug.SetGCPercent```只在有必要的情况下才会触发GC。
- [go.1.10](https://golang.org/doc/go1.10)，小优化，加速了GC，程序应当运行更快一点点。
- [go1.12](https://golang.org/doc/go1.12)，显著提高了堆内存存在大碎片情况下的 sweeping 性能，能够降低 GC 后立即分配内存的延迟。
- [go1.13](https://golang.org/doc/go1.13)，着手解决向操作系统归还内存的，提出了新的 Scavenger
- [go1.14](https://golang.org/doc/go1.14)，替代了仅存活了一个版本的 Scavenger，全新的页分配器，优化分配内存过程的速率与现有的扩展性问题，并引入了异步抢占，解决了由于密集循环导致的 STW 时间过长的问题

**主要版本优化：**
- 1.5 版本以及以后版本的 GC 主要分为四个阶段，其中标记和清理都是并发执行的，但是标记阶段的前后需要使用 STW 来做 GC 的准备工作和栈的 rescan（这也是1.8的优化点）。
- 1.8 版本引入混合屏障，最小化第一次 STW，写入屏障和删除屏障各有优缺点，Dijkstra 写入写屏障在标记开始时无需 STW，可直接开始，并发进行，但结束时需要STW来重新扫描栈，标记栈上引用的白色对象的存活；Yuasa 的删除写屏障则需要在 GC 开始时 STW 扫描堆栈来记录初始快照，这个过程会保护开始时刻的所有存活对象，但结束时无需 STW。Go1.8 版本引入的混合写屏障结合了 Yuasa 的删除写屏障和 Dijkstra 的写入写屏障，结合了两者的优点
![GC算法环节](/img/post/lang/go/GC算法环节.png)

## GC算法
[常见 GC 算法详情](https://bailing1992.github.io/2021/11/18/lang-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%97%E6%B3%95/)

**Golang GC 算法使用的是无分代（对象没有代际之分）、不整理（回收过程中不对对象进行移动与整理）、并发（与用户代码并发执行）的三色标记清扫算法。** 原因在于：
* 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于 ```tcmalloc```，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于 ```tcmalloc``` 的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。
* 分代 GC 依赖分代假设，即 GC 将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。但 Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代 GC 回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当 goroutine 死亡后栈也会被直接回收，不需要 GC 的参与，进而分代假设并没有带来直接优势。并且 Go 的垃圾回收器与用户代码并发执行，使得 STW 的时间与对象的代际、对象的 size 没有关系。Go 团队更关注于如何更好地让 GC 与用户代码并发执行（使用适当的 CPU 来执行垃圾回收），而非减少停顿时间这一单一目标上。

#### 三色标记法原理
三色标记法将对象分为三类，并用不同的颜色相称：
- 白色对象（可能死亡）：未被回收器访问到的对象。在回收开始阶段，所有对象均为白色，当回收结束后，白色对象均不可达。
- 灰色对象（波面）：已被回收器访问到的对象，但回收器需要对其中的一个或多个指针进行扫描，因为他们可能还指向白色对象。
- 黑色对象（确定存活）：已被回收器访问到的对象，其中所有字段都已被扫描，黑色对象中任何一个指针都不可能直接指向白色对象。
![GC算法环节](/img/post/lang/go/三色标记法.gif)

标记过程如下：
1. 起初所有的对象都是白色的；
2. 从根对象出发扫描所有可达对象，标记为灰色，放入待处理队列；
3. 从待处理队列中取出灰色对象，将其引用的对象标记为灰色并放入待处理队列中，自身标记为黑色；
4. 重复步骤（3），直到待处理队列为空，此时白色对象即为不可达的“垃圾”，回收白色对象；

> 根对象在垃圾回收的术语中又叫做根集合，它是垃圾回收器在标记过程时最先检查的对象，包括：
> 1. 全局变量：程序在编译期就能确定的那些存在于程序整个生命周期的变量。 
> 2. 执行栈：每个 goroutine 都包含自己的执行栈，这些执行栈上包含栈上的变量及指向分配的堆内存区块的指针。
> 3. 寄存器：寄存器的值可能表示一个指针，参与计算的这些指针可能指向某些赋值器分配的堆内存区块。

#### 屏障机制
##### STW
STW 可以是 Stop The World 的缩写，也可以是 Start The World 的缩写。通常意义上指的是从 Stop The World 到 Start The World 这一段时间间隔。**垃圾回收过程中为了保证准确性、防止无止境的内存增长等问题而不可避免的需要停止赋值器进一步操作对象图以完成垃圾回收**。STW 时间越长，对用户代码造成的影响越大。
##### No STW 存在的问题
假设下面的场景，已经被标记为灰色的**对象2**，未被标记的**对象3**被**对象2**用指针 p 引用；此时已经被标记为黑色的**对象4**创建指针 q 指向未被标记的**对象3**，同时**对象2**将指针 p 移除；**对象4**已经被标记为黑色，**对象3**未被引用，**对象2**删除与**对象3**的引用，导致最后**对象3**被误清除； 
![STW存在的问题](/img/post/lang/go/STW存在的问题1.png)
![STW存在的问题](/img/post/lang/go/STW存在的问题2.png)
![STW存在的问题](/img/post/lang/go/STW存在的问题3.png)
![STW存在的问题](/img/post/lang/go/STW存在的问题4.png)
![STW存在的问题](/img/post/lang/go/STW存在的问题5.png)


垃圾回收的原则是不应出现对象的丢失，也不应错误的回收还不需要回收的对象。如果同时满足下面两个条件会破坏回收器的正确性：
- 条件 1: 赋值器修改对象图，导致某一黑色对象引用白色对象（通俗的说就是 A 突然持有了 B 的指针，而 B 在并发标记的过程中已经被判定为白色对象要被清理掉的）
- 条件 2: 从灰色对象出发，到达白色对象的路径未经访问过且被赋值器破坏（通俗的说就是 A 持有 B 的指针，这个持有关系被释放）

只要能够避免其中任何一个条件，则不会出现对象丢失的情况，因为：
- 如果**条件 1**被避免，则所有白色对象均被灰色对象引用，没有白色对象会被遗漏；
- 如果**条件 2**被避免，即便白色对象的指针被写入到黑色对象中，但从灰色对象出发，总存在一条没有访问过的路径，从而找到到达白色对象的路径，白色对象最终不会被遗漏。

可能的解决方法： 整个过程 STW，浪费资源，且对用户程序影响较大，由此引入了屏障机制。

##### 屏障机制
把回收器视为对象，把赋值器视为影响回收器这一对象的实际行为（即影响 GC 周期的长短），从而引入赋值器的颜色：
- 黑色赋值器：已经由回收器扫描过，不会再次对其进行扫描。
- 灰色赋值器：尚未被回收器扫描过或尽管已经扫描过，但仍需要重新扫描。

###### 插入屏障（Dijkstra）- 灰色赋值器
写入前，对指针所要指向的对象进行着色。 避免条件1（赋值器修改对象图，导致某一黑色对象引用白色对象。）因为在对象 A 引用对象 B 的时候，B 对象被标记为灰色
```java
// 灰色赋值器 Dijkstra 插入屏障
func DijkstraWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(ptr) //先将新下游对象 ptr 标记为灰色
    *slot = ptr
}

//说明：
添加下游对象(当前下游对象slot, 新下游对象ptr) {   
  //step 1
  标记灰色(新下游对象ptr)   
  
  //step 2
  当前下游对象slot = 新下游对象ptr                    
}
 
//场景：
A.添加下游对象(nil, B)   //A 之前没有下游， 新添加一个下游对象B， B被标记为灰色
A.添加下游对象(C, B)     //A 将下游对象C 更换为B，  B被标记为灰色
```

Dijkstra 插入屏障的好处在于可以立刻开始并发标记。但存在两个缺点：
* 由于 Dijkstra 插入屏障的“保守”，在一次回收过程中可能会残留一部分对象没有回收成功，只有在下一个回收过程中才会被回收；
* 在标记阶段中，每次进行指针赋值操作时，都需要引入写屏障，这无疑会增加大量性能开销；为了避免造成性能问题，Go 团队在最终实现时，没有为所有栈上的指针写操作，启用写屏障，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了灰色赋值器，将会需要标记终止阶段 STW 时对这些栈进行重新扫描。
       
![插入屏障流程](/img/post/lang/go/插入屏障流程1.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程2.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程3.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程4.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程5.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程6.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程7.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程8.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程9.png)
![插入屏障流程](/img/post/lang/go/插入屏障流程10.png)
**特点：在标记开始时无需 STW，可直接开始，并发进行，但结束时需要 STW 来重新扫描栈**

###### 删除屏障 （Yuasa）- 黑色赋值器
写入前，对指针所在对象进行着色。避免条件2（从灰色对象出发，到达白色对象的、未经访问过的路径被赋值器破坏），因为被删除对象，如果自身是灰色或者白色，则被标记为灰色
```java
// 黑色赋值器 Yuasa 屏障
func YuasaWritePointer(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot) 先将*slot标记为灰色
    *slot = ptr
}

//说明：
添加下游对象(当前下游对象slot， 新下游对象ptr) {
  //step 1
  if (当前下游对象slot是灰色 || 当前下游对象slot是白色) {
          标记灰色(当前下游对象slot)     //slot为被删除对象， 标记为灰色
  }  
  //step 2
  当前下游对象slot = 新下游对象ptr
}
//场景
A.添加下游对象(B, nil)   //A对象，删除B对象的引用。B被A删除，被标记为灰(如果B之前为白)
A.添加下游对象(B, C)     //A对象，更换下游B变成C。B被A删除，被标记为灰(如果B之前为白)
```

![删除屏障流程](/img/post/lang/go/删除屏障流程1.png)
![删除屏障流程](/img/post/lang/go/删除屏障流程2.png)
![删除屏障流程](/img/post/lang/go/删除屏障流程3.png)
![删除屏障流程](/img/post/lang/go/删除屏障流程4.png)
![删除屏障流程](/img/post/lang/go/删除屏障流程5.png)
![删除屏障流程](/img/post/lang/go/删除屏障流程6.png)
![删除屏障流程](/img/post/lang/go/删除屏障流程7.png)

**特点:标记结束不需要 STW，但是回收精度低，GC 开始时 STW 扫描堆栈记录初始快照，保护开始时刻的所有存活对象；且容易产生“冗余”扫描**

###### 混合屏障
大大缩短了 STW 时间:
- GC 开始将栈上的对象全部扫描并标记为黑色；
- GC 期间，任何在栈上创建的新对象，均为黑色；
- 被删除的堆对象标记为灰色；
- 被添加的堆对象标记为灰色；
```java
// 混合写屏障
func HybridWritePointerSimple(slot *unsafe.Pointer, ptr unsafe.Pointer) {
    shade(*slot)
    shade(ptr)
    *slot = ptr
}
```

![混合屏障流程](/img/post/lang/go/混合屏障流程1.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程2.png)

**场景一：对象被一个堆对象删除引用，成为栈对象的下游**

由于屏障的作用，对象7不会被误删除；  
![混合屏障流程](/img/post/lang/go/混合屏障流程3.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程4.png)
场景二：对象被一个栈对象删除引用，成为栈对象的下游   
![混合屏障流程](/img/post/lang/go/混合屏障流程5.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程6.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程7.png)


场景三：对象被一个堆对象删除引用，成为堆对象的下游   
![混合屏障流程](/img/post/lang/go/混合屏障流程8.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程9.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程10.png)



场景四：对象被一个栈对象删除引用，成为另一个堆对象的下游   

![混合屏障流程](/img/post/lang/go/混合屏障流程11.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程12.png)
![混合屏障流程](/img/post/lang/go/混合屏障流程13.png)


**Golang 中的混合屏障结合了删除写屏障和插入写屏障的优点，只需要在开始时并发扫描各goroutine的栈，使其变黑并一直保持，标记结束后，因为栈空间在扫描后始终是黑色的，无需进行re-scan，减少了STW 的时间。**

#### Go GC过程
##### 标记清理
###### Marking setup
为了打开写屏障，必须停止每个 goroutine，让垃圾收集器观察并等待每个 goroutine 进行函数调用， 等待函数调用是为了保证 goroutine 停止时处于安全点。 
![安全点](/img/post/lang/go/安全点.png)

```go
// 如果goroutine4 处于如下循环中，运行时间取决于slice numbers的大小
func add(numbers []int) int {
    var v int
    for _, n := range numbers {
             v += n
     }
     return v
}
```
下面的代码中，由于 ```for{} ```循环所在的 goroutine 永远不会中断，导致始终无法进入 STW 阶段，资源浪费；Go 1.14 之后，此类 goroutine 能被异步抢占，使得进入 STW 的时间不会超过抢占信号触发的周期，程序也不会因为仅仅等待一个 goroutine 的停止而停顿在进入 STW 之前的操作上。
```go
func main() {
    go func() {
        for {
        }
    }()
    time.Sleep(time.Milliecond)
    runtime.GC()
    println("done")
}
```


###### Marking
一旦写屏障打开，垃圾收集器就开始标记阶段，垃圾收集器所做的第一件事是占用 ```25%``` CPU。

标记阶段需要标记在堆内存中仍然在使用中的值。首先检查所有现goroutine的堆栈，以找到堆内存的根指针。然后收集器必须从那些根指针遍历堆内存图，标记可以回收的内存。

当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。 
![对象标记](/img/post/lang/go/对象标记.png)

###### Mark终止
关闭写屏障，执行各种清理任务（STW - optional ） 
![清理](/img/post/lang/go/清理.png)

###### Sweep (清理)

清理阶段用于回收标记阶段中标记出来的可回收内存。当应用程序 goroutine尝试在堆内存中分配新内存时，会触发该操作，清理导致的延迟和吞吐量降低被分散到每次内存分配时。 


**清除阶段出现新对象：**

清除阶段是扫描整个堆内存，可以知道当前清除到什么位置，创建的新对象判定下，如果新对象的指针位置已经被扫描过了，那么就不用作任何操作，不会被误清除，如果在当前扫描的位置的后面，把该对象的颜色标记为黑色，这样就不会被误清除了

**什么时候进行清理？**

主动触发（runtime.GC()） 被动触发 （GC百分比、定时）
###### 总结
![清理](/img/post/lang/go/清理2.png)
