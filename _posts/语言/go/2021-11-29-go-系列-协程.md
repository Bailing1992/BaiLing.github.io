---
layout: post
title: "Go 系列 协程"
author: "lichao"
header-img: "img/post/bg/post-bg-ngon-ngu-golang.jpg"
catalog: true
tags:
  - go
---

## 背景
#### 连接独占线程模式
早期的网络程序链接数目和QPS比较低，一个进程或者线程会处理一个网络请求。
随着技术的发展，互联网不再是单纯的浏览万维网网页，逐渐开始与用户进行交互。而且应用程序的逻辑也变得更复杂：从简单的表单提交到即时通信和在线实时互动。每一个用户都必须与服务器保持TCP连接才能进行实时的数据交互。当进程或者线程由于IO阻塞的时候，操作系统就会进行线程或者进程的切换。

**线程或者进程切换会带来大量的系统开销和上下文切换成本，导致严重的系统开销。**

- 切换进程系统开销：
  1. 切换虚拟地址空间；
  2. 切换内核栈；
  3. 切换硬件上下文；
- 进程或者线程切换后，会导致一段时间程序运行速度大幅度变慢：
  1. 丢失寄存器中的内容
  2. CPU cache失效：现代cpu速度提升很大一部原因是因为Cache的引入。
  3. TLB 快表失效(所有的内存操作时间翻番直到TLB加载完成)

|   存储类型   |    耗时     |
|     --      |     --     |
|  L1 cache   |    0.5ns   |
|  L2 cache   |     7ns    |
|  内存        |   100ns    |

#### C10K问题
一个服务器多线程方式处理10000个连接后，线程切换成本会变得十分巨大，性能会急剧下降。
百度的经验上看，不考虑互斥逻辑情况下，多线程每次切换需要3-5微秒的上线文切换代价和1微秒的cache同步代价。简单的echo程序，处理一个请求需要200~300ns，在单核的docker上可以处理300-500万请求；在24核的如果考虑切换，单线程的处理能力会降至10万，整体性能会降低到240万。