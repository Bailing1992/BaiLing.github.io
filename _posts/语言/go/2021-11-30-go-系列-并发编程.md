---
layout: post
title: "Go 系列 并发编程"
author: "lichao"
header-img: "img/post/bg/post-bg-ngon-ngu-golang.jpg"
catalog: true
tags:
  - go
---


## 抢占式调度

在 go 1.14 前，go 并非完全的抢占式调度，如下代码会陷入死循环：

```go 
package main
import (
    "fmt"
    "runtime"
    "time"
)
func main() {
    runtime.GOMAXPROCS(1)

    fmt.Println("The program starts ...")

    go func() {
        for {
        }
    }()

    time.Sleep(time.Second)
    fmt.Println("I got scheduled!")
}
```
如果检测到某个 P 的状态为 Prunning，并且它已经运行了超过10ms，则会将P的当前的G的stackguard 设置为 StackPreempt。这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。如果没有函数调用或者主动调用 runtime.Gosched() 的话将会陷入死循环。

**Go 1.14 引入了基于系统信号的异步抢占调度，在循环中无函数调用的情况下也能被抢占出让 P，同样的代码则会正常运行。runtime 的 sysmon 负责进行运行时间的检查，在```src/runtime/proc.go``` 中有定义变量 ```forcePreemptNS```，在超过时限后会发送 ```SIGURG``` 信号，通知相应协程让出调度。**

```go 
// forcePreemptNS is the time slice given to a G before it is
// preempted.
const forcePreemptNS = 10 * 1000 * 1000 // 10ms
```
在 mac 本地运行测试，如图所示在循环中约每 20 ms goroutine 都会被中断一次。

