---
layout: post
title: "Go 系列 并发编程"
author: "lichao"
header-img: "img/post/bg/post-bg-ngon-ngu-golang.jpg"
catalog: true
tags:
  - go
---


> Go 中的 goroutine 之间没有父与子的关系，也就没有所谓子进程退出后的通知机制。多个 goroutine 都是平行地被调度，多个 goroutine 如何协作工作涉及通信、同步、通知和退出四个方面。
> - **通信**： chan 通道当然是 goroutine 之间通信的基础（这里的通信是指程序的数据通道）。
> - **同步**： 不带缓冲的 chan 提供一个天然的同步等待机制；当然 sync.WaitGroup 也为多个 goroutine 协同工作提供一种同步等待机制。
> - **通知**：通知通常不是业务数据，而是管理、控制流数据。可以使用 chan，并结合 select 收敛进行处理。
> - **推出**：goroutine 之间没有 父子关系，可以利用 context 包提供多个 goroutine 之间的退出通知功能。


## 抢占式调度

在 go 1.14 前，go 并非完全的抢占式调度，如下代码会陷入死循环：

```go 
package main
import (
    "fmt"
    "runtime"
    "time"
)
func main() {
    runtime.GOMAXPROCS(1)

    fmt.Println("The program starts ...")

    go func() {
        for {
        }
    }()

    time.Sleep(time.Second)
    fmt.Println("I got scheduled!")
}
```
如果检测到某个 P 的状态为 Prunning，并且它已经运行了超过10ms，则会将P的当前的G的stackguard 设置为 StackPreempt。这个操作其实是相当于加上一个标记，通知这个G在合适时机进行调度。如果没有函数调用或者主动调用 runtime.Gosched() 的话将会陷入死循环。

**Go 1.14 引入了基于系统信号的异步抢占调度，在循环中无函数调用的情况下也能被抢占出让 P，同样的代码则会正常运行。runtime 的 sysmon 负责进行运行时间的检查，在```src/runtime/proc.go``` 中有定义变量 ```forcePreemptNS```，在超过时限后会发送 ```SIGURG``` 信号，通知相应协程让出调度。**

```go 
// forcePreemptNS is the time slice given to a G before it is
// preempted.
const forcePreemptNS = 10 * 1000 * 1000 // 10ms
```
在 mac 本地运行测试，如图所示在循环中约每 20 ms goroutine 都会被中断一次。

