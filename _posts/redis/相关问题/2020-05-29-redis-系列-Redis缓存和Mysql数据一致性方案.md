---
layout: post
title: "redis 系列 Redis 缓存和 MySQL 数据一致性方案"
subtitle: '开启 redis 探索新篇章'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - redis 
---


> 数据库 和 缓存更新时，就容易出现缓存(Redis)和数据库（MySQL）间的数据一致性问题。

> 先做一个说明，从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。因此，接下来讨论的思路不依赖于给缓存设置过期时间这个方案。

> 大部分情况下添加缓存的一个重要目的是为了减少请求的响应时间，事务操作会给我们的业务代码带来额外的复杂性同时也极大的限制了性能，缓存也就意义不大了。

## 方案
在这里，讨论四种更新策略：
1. 先更新缓存，再更新数据库
2. 先更新数据库，再更新缓存
3. 先删除缓存，再更新数据库
4. 先更新数据库，再删除缓存


#### 先更新缓存，再更新数据库
这个方案是业界绝对不可取的，原因就是：

1. 先更新缓存，可能会让数据库的读操作得不到利用，缓存被频繁更新，浪费数据库的读取性能
2. 当更新数据库失败时，缓存和数据库的数据将变得不可靠，会发生什么就很难判断了




#### 先更新数据库，再更新缓存
这套方案，大家是普遍反对的。为什么呢？有如下两点原因。

**原因一（线程安全角度）**

同时有请求 A 和请求 B 进行更新操作，那么会出现:
1. 线程 A 更新了数据库
2. 线程 B 更新了数据库
3. 线程 B 更新了缓存
4. 线程 A 更新了缓存
这就出现请求 A 更新缓存应该比请求 B 更新缓存早才对，但是因为网络等原因，B 却比 A 更早更新了缓存。这就导致了脏数据，因此不考虑。

**原因二（业务场景角度）** 

有如下两点：
1. 如果你是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。
2. 如果你写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。

#### 先删缓存，再更新数据库
该方案会导致不一致的原因是，同时有一个请求 A 进行更新操作，另一个请求 B 进行查询操作。那么会出现如下情形:

1. 请求 A 准备进行写操作，先删除缓存
2. 请求 B 查询发现缓存不存在
3. 请求 B 去数据库查询得到旧值
4. 请求 B 将旧值写入缓存
5. 请求 A 将新值写入数据库

上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。

**出现不一致的根本原因：**

1. 单库情况下，服务层在进行 1s 的逻辑计算过程中，可能读到旧数据入缓存
2. 主从库+读写分离情况下，在 1s 钟主从同步延时过程中，可能读到旧数据入缓存

###### 单库情况下，服务层的并发读写，缓存与数据库的操作交叉进行

![存储概览](/img/redis/28.webp)
虽然只有一个 DB，在上述异常时序下，也可能脏数据入缓存：

1. 请求 A 发起一个写操作，第一步淘汰了 cache，然后这个请求因为各种原因在服务层卡住了（进行大量的业务逻辑计算，例如计算了 1 秒钟），如上图步骤1
2. 请求 B 发起一个读操作，读 cache，cache miss，如上图步骤2
3. 请求 B 继续读 DB，读出来一个脏数据，然后脏数据入 cache，如上图步骤3
4. 请求 A 等了很久后终于写数据库了，写入了最新的数据，如上图步骤4

这种情况虽然少见，但理论上是存在的，后发起的请求 B 在先发起的请求 A 中间完成了。

###### 主从同步、读写分离的情况下，读从库读到旧数据
在数据库架构做了一主多从，读写分离时，更多的脏数据入缓存是下面这种情况：
![存储概览](/img/redis/29.webp)

1. 请求 A 发起一个写操作，第一步淘汰了 cache，如上图步骤 1
2. 请求 A 写数据库了，写入了最新的数据，如上图步骤 2
3. 请求 B 发起一个读操作，读 cache，cache miss，如上图步骤 3
4. 请求 B 继续读 DB，读的是从库，此时主从同步还没有完成，读出来一个脏数据，然后脏数据入 cache，如上图步 4
5. 最后数据库的主从同步完成了，如上图步骤 5

这种情况请求 A 和请求 B 的时序是完全没有问题的，是主动同步的时延（假设延时 1 秒钟）中间有读请求读从库读到脏数据导致的不一致。

#### 先更新数据库，再删缓存
《Cache-Aside pattern》中指出的删除缓存的方法:
* 失效：应用程序先从 cache 取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。
* 命中：应用程序从 cache 中取数据，取到后返回。
* 更新：先把数据存到数据库中，成功后，再让缓存失效

###### 这种情况不存在并发问题么？
不是的。假设这会有两个请求，一个请求 A 做查询操作，一个请求 B 做更新操作，那么会有如下情形产生: 
1. 缓存刚好失效
2. 请求 A 查询数据库，得一个旧值
3. 请求 B 将新值写入数据库
4. 请求 B 删除缓存
5. 请求 A 将查到的旧值写入缓存
如果发生上述情况，确实是会发生脏数据

###### 发生这种情况的概率又有多少呢？
发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。

###### 如何解决上述并发问题？
首先，给缓存设有效时间是一种方案。其次，采用下面的延时双删策略里给出的异步延时删除策略，保证读请求完成以后，再进行删除操作。

#### 采用延时双删策略
```
public void write(String key,Object data){
        redis.delKey(key);
        db.updateData(data);
        Thread.sleep(1000);
        redis.delKey(key);
}
```

在写库前后都进行 ```redis.del(key);``` 操作，并且设定合理的超时时间。

具体的步骤就是: 
1. 先删除缓存
2. 再写数据库
3. 休眠 1 秒
4. 再次删除缓存
这么做，可以将 1 秒内所造成的缓存脏数据，再次删除

**带来的问题是：**
所有的写请求都阻塞了 1 秒，大大降低了写请求的吞吐量，增长了处理时间，业务上是接受不了的。其实第二次淘汰缓存是“为了保证缓存一致”而做的操作，而不是“业务要求”，所以其实无需等待，用一个异步的 timer，或者利用消息总线异步的来做这个事情即可

![存储概览](/img/redis/30.webp)

消息总线 esb 发送一个消息，发送完成之后马上就能返回，而在下游，有一个异步淘汰缓存的消费者，在接收到消息之后，asy-expire在1s之后淘汰缓存。这样，即使1s内有脏数据入缓存，也有机会再次被淘汰掉。

![存储概览](/img/redis/31.webp)

###### 这个 1 秒怎么确定的，具体该休眠多久呢？
针对上面的情形，应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百 ms 即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。

###### 如果用了 MySQL 的读写分离架构怎么办？
在这种情况下，造成数据不一致的原因如下，还是两个请求，一个请求 A 进行更新操作，另一个请求 B 进行查询操作。
1. 请求 A 进行写操作，删除缓存
2. 请求 A 将数据写入数据库了，
3. 请求 B 查询缓存发现，缓存没有值
4. 请求 B 去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
5. 请求 B 将旧值写入缓存
6. 数据库完成主从同步，从库变为新值
上述情形，就是数据不一致的原因。还是使用双删延时策略。只是，睡眠时间修改为在主从同步的延时时间基础上，加几百 ms。

###### 采用这种同步淘汰策略，吞吐量降低怎么办？
那就将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。

###### 还有其它造成不一致的原因么？
有的，这也是缓存后删除策略和缓存双删策略都存在的一个问题，如果删缓存失败了怎么办，那不是会有不一致的情况出现么。比如一个写数据请求，然后写入数据库了，删缓存失败了，这会就出现不一致的情况了。

###### 第二次删除，如果删除失败怎么办？
因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求 A 进行更新操作，另一个请求 B 进行查询操作，为了方便，假设是单库：
1. 请求 A 进行写操作，删除缓存
2. 请求 B 查询发现缓存不存在
3. 请求 B 去数据库查询得到旧值
4. 请求 B 将旧值写入缓存
5. 请求 A 将新值写入数据库
6. 请求 A 试图去删除请求B写入对缓存值，结果失败了。
这也就是说。如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。

#### 如何处理删除缓存失败？
提供一个保障的重试机制即可，这里给出两套方案。

**方案一**

![存储概览](/img/redis/26.png)

流程如下所示:
1. 更新数据库数据；
2. 缓存因为种种问题删除失败
3. 将需要删除的 key 发送至消息队列
4. 自己消费消息，获得需要删除的 key
5. 继续重试删除操作，直到成功
然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。

**方案二**
![存储概览](/img/redis/27.jpeg)
流程如下图所示：
1. 更新数据库数据
2. 数据库会将操作信息写入 binlog 日志当中
3. 订阅程序提取出所需要的数据以及 key
4. 另起一段非业务代码，获得该信息
5. 尝试删除缓存操作，发现删除失败
6. 将这些信息发送至消息队列
7. 重新从消息队列中获得该数据，重试操作

备注说明：上述的订阅 binlog 程序在 MySQL 中有现成的中间件叫 Canal，可以完成订阅 binlog 日志的功能。另外，重试机制，可以采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可，可以灵活自由发挥，只是提供一个思路。


## 参考文献

https://www.jianshu.com/p/e3f5ff55f0fd

[引用自](https://cloud.tencent.com/developer/article/1165508)
[引用自](https://www.veaxen.com/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94.html
)

