---
layout: post
title: "redis 系列 过期清除"
subtitle: '开启 redis 探索新篇章'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - redis 
---


> Redis 作为缓存使用最主要的一个特性就是可以为键值对设置过期时间

在 Redis 中与过期时间有关的命令:
* EXPIRE 设置 key 的存活时间单位秒
* EXPIREAT 设置 key 的过期时间点单位秒
* PEXPIRE 设置 key 的存活时间单位毫秒
* PEXPIREAT 设置 key 的过期时间点单位毫秒

其实这些命令，底层的命令都是由 REXPIREAT 实现的。
在 redisDb 中使用了 **dict *expires** 来存储过期时间的。其中 key 指向了 keyspace 中的 key（c 语言中的指针）， value 是一个 long long 类型的时间戳，标定这个 key 过期的时间点，单位是毫秒。

如果我们为上文的 mobile 增加一个过期时间。

```
> redis PEXPIREAT mobile 1521469812000
```

复制代码这个时候就会在过期的 字典中增加一个键值对。如下图：
![存储概览](/img/redis/32.png)

对于过期的判断逻辑就很简单：
1. 在 字典 expires 中 key 是否存在。
2. 如果 key 存在，value 的时间戳是否小于当前系统时间戳。

## 删除策略

**这三种策略就是对时间和空间有不同的倾向。Redis为了平衡时间和空间，采用了后两种策略 惰性删除和定时部分删除。**

key 删除有三种策略：

1. 定时删除，Redis定时的删除内存里面所有过期的键值对，这样能够保证内存友好，过期的key都会被删除，但是如果key的数量很多，一次删除需要CPU运算，CPU不友好。
2. 惰性删除，只有 key 在被调用的时候才去检查键值对是否过期，但是会造成内存中存储大量的过期键值对，内存不友好，但是极大的减轻CPU 的负担。
3. 定时部分删除，Redis定时扫描过期键，但是只删除部分，至于删除多少键，根据当前 Redis 的状态决定。

#### 定时删除

过期键的定时删除的策略由 ```expire.c/activeExpireCycle()``` 函数实现， ```server.c/serverCron()``` 定时的调用 ```activieExpireCycle()``` 。
activeExpireCycle 的大的操作原则是，如果过期的 key 比较少，则删除 key 的数量也比较保守，如果，过期的键多，删除 key的 策略就会很激进。

```
static unsigned int current_db = 0; /* Last DB tested. */
static int timelimit_exit = 0;      /* Time limit hit in previous call? */
static long long last_fast_cycle = 0; /* When last fast cycle ran. */

```

* 首先三个 static 全局参数分别记录目前遍历的 db下标，上一次删除是否是超时退出的，上一次快速操作是什么时候进行的。
* 计算 ```timelimit = 1000000*ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC/server.hz/100;``` 可以理解为 25% 的 cpu 时间。
* 如果 db 中 expire 的大小为 0 不操作
* expire 占总 key 小于 1% 不操作
* ```num = dictSize(db->expires)；```num 是 expire 使用的 key 的数量
* ```slots = dictSlots(db->expires);``` slots 是 expire 字典的尺寸大小。
* 已使用的key（num） 大于 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 则设置为 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP。也就是说每次只检查 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 个键。
* 随机获取带过期的 key。计算是否过期，如果过期就删除。
* 然后各种统计，包括删除键的次数，平均过期时间。
* 每遍历十六次，计算操作时间，如果超过 timelimit 结束返回。
* 如果删除的过期键大于 ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP 的 1\4 就跳出循环，结束。

步骤比较复杂，总结一下：（这里都是以默认配置描述）

1. redis 会用最多 25% 的 cpu 时间处理键的过期。
2. 遍历所有的 redisDb
3. 在每个 redisDb 中如果数据中没有过期键或者过期键比例过低就直接进入下一个 redisDb。
4. 否则，遍历 redisDb 中的过期键，如果删除的键达到有过期时间的的key 的25% ，或者操作时间大于 cpu 时间的 25% 就结束当前循环，进入下一个redisDb。

## 综述
这篇文章主要解释了 Redis 的数据库是怎么实现的，同时介绍了 Redis 处理过期键的逻辑。看 Redis 的代码越多越发现，实际上 Redis 一直在做的一件事情就是平衡，一直在平衡程序的空间和时间。

## 参考文献
https://juejin.im/post/5ab0d717f265da2380597974