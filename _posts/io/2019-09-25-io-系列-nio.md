---
layout: post
title: "IO 系列 IO多路复用"
author: "lichao"
header-img: "img/netty/host.png"
catalog: true
tags:
  - io
---

## 多路复用（事件轮询）
![select示意图](/img/io/select示意图.png)
最简单的事件轮询 API 是 select 函数，它是操作系统提供给用户程序的 API。输入是读写描述符列表 read_fds & write_fds，输出是与之对应的可读可写事件。同时还提供了一个 timeout 参数，如果没有任何事件到来，那么就最多等待 timeout 时间，线程处于阻塞状态。一旦期间有任何事件到来，就可以立即返回。时间过了之后还是没有任何事件到来，也会立即返回。拿到事件后，线程就可以继续挨个处理相应的事件。处理完了继续过来轮询。于是线程就进入了一个死循环，这个死循环称为事件循环，一个循环为一个周期。

在 UNIX 系统上，一切皆文件。套接字也不例外，每一个套接字都有对应的 fd（即文件描述符）。

通过 select 系统调用同时处理多个通道描述符的读写事件，因此将这类系统调用称为多路复用 API。现代操作系统的多路复用 API 已经不再使用 select 系统调用，而改用 epoll(linux) 和 kqueue(freebsd & macosx)，因为 select 系统调用的性能在描述符特别多时性能会非常差。


#### select
select 是一种内核无状态的实现。即对于每一次系统调用，内核不会记录下任何信息，所以每次调用都需要重复传递相同信息。
```
select(int nfds, fd_set *r, fd_set *w, fd_set *e, struct timeval *timeout)
```

```select()``` 需要传 3 个集合，r、w 和 e。其中，r 表示对哪些 fd 的可读事件感兴趣，w 表示对哪些 fd 的可写事件感兴趣。每个集合其实是一个 bitmap，通过 0/1 表示我们感兴趣的 fd。例如，对于 fd 为 6 的可读事件感兴趣，那么r 集合的第 6 个 bit 需要被设置为 1。这个系统调用会阻塞，直到感兴趣的事件（至少一个）发生。调用返回时，内核同样使用这 3 个集合来存放 fd 实际发生的事件信息。也就是说，调用前这 3 个集合表示我们感兴趣的事件，调用后这3个集合表示实际发生的事件。

select 为最早期的 UNIX 系统调用，它存在 4 个问题：
1. 这 3 个 bitmap 有大小限制（FD_SETSIZE，通常为 1024），select 单个进程打开的最大句柄数是有限的。
2. 由于这 3 个集合在返回时会被内核修改，因此每次调用时都需要重新设置。
3. 在调用完成后需要扫描这 3 个集合才能知道哪些 fd 的读/写事件发生了，一般情况下全量集合比较大而实际发生读/写事件的 fd 比较少，效率比较低下。
4. 内核在每次调用都需要扫描这 3 个 fd 集合，然后查看哪些 fd 的事件实际发生，在读/写比较稀疏的情况下同样存在效率问题。


> 默认情况下，单个进程最多允许打开的文件句柄数（包括 socket 连接数）是有限制的，当大于这个系统限制时，程序会抛出大量的无法打开文件的报错。[可修改配置](https://blog.csdn.net/dutsoft/article/details/51248725)


#### poll
poll 同样 是一种内核无状态的实现。

```
poll(struct pollfd *fds, int nfds, int timeout)

struct pollfd {
    int fd;
    short events;
    short revents;
}
```

poll 调用需要传递的是一个 pollfd 结构的数组，调用返回时结果信息也存放在这个数组里面。 pollfd 的结构中存放着 fd、我们对该 fd 感兴趣的事件(events)以及该 fd 实际发生的事件(revents)。poll 传递的不是固定大小的bitmap，因此 select 的问题 1 解决了；poll 将感兴趣事件和实际发生事件分开了，因此 select 的问题 2 也解决了。但 select 的问题 3 和问题 4 仍然没有解决。
#### epoll
epoll  是一种内核有状态的实现。epoll 是 Linux 中的实现。

```
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);
```
epoll_create 的作用是创建一个context，这个context相当于状态保存者的概念。
epoll_ctl 的作用是，当对一个新的fd的读/写事件感兴趣时，通过该调用将fd与相应的感兴趣事件更新到context中。
epoll_wait 的作用是，等待context中fd的事件发生。


## 参考文献
[Redis与Reactor模式](https://www.open-open.com/lib/view/open1452486726589.html)
[Reactor论文](http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf)
[NIO](http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf)


