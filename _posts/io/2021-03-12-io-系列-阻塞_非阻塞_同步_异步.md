---
layout: post
title: "Netty 系列 阻塞/非阻塞/同步/异步"
author: "lichao"
header-img: "img/netty/host.png"
catalog: true
tags:
  - io
---

## 同步与异步
同步和异步关注的是消息通信机制：

* 所谓同步，就是在发出一个**调用**时，在没有得到结果之前，该**调用**就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由 **调用者**主动等待这个**调用**的结果。

* 而异步则是相反，**调用**在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在**调用**发出后，**被调用者**通过状态、通知来通知调用者，或通过回调函数处理这个调用。

## 阻塞与非阻塞
阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：
* 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
* 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。


## I/O 模型
根据UNIX网络编程对IO模型的分类，UNIX提供了5种IO模型。
#### 阻塞式I/O
默认情况下，所有套接字都是阻塞的。先理解这么个流程，一个输入操作通常包括两个不同阶段：
1. 等待数据准备好
2. 从内核向进程复制数据

对于一个套接字上的输入操作，第一步通常涉及等待数据从网络中到达。当所有等待分组到达时，它被复制到内核中的某个缓冲区。第二步就是把数据从内核缓冲区复制到应用程序缓冲区。 下面以阻塞套接字的recvfrom的调用图来说明阻塞，标红的这部分过程就是阻塞，直到阻塞结束recvfrom才能返回：
![netty](/img/netty/netty2.jpg)
#### 非阻塞式I/O
recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞IO模型进行轮询检查这个状态，看内核是不是有数据到来。
![netty](/img/netty/netty3.jpg)

#### I/O 复用（select，poll，epoll...）
Linux 提供 select/poll，进程通过将一个或多个fd传递给 select/poll系统调用，阻塞到select操作上，这样select/poll可以帮我们侦测多个fd 是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd的数量有限，因此它的使用受到了一些约束。Linux提供的epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。
虽然 I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。
![netty](/img/netty/netty4.jpg)

##### select VS epoll
IO多路复用技术通过把多个IO的阻塞复用到同一个select的阻塞上，从而使得系统在单线程的情况下可以同时处理多个客户端的请求。
 1. epoll 相比于 select，支持一个进程打开的socket描述符（FD）不受限制
 2. IO 效率不会随着FD数目的增加而线性下降。select/poll每次调用都会线性扫描全部的集合，导致效率呈现线性下降。epoll只会对活跃的socket进行操作（epoll是根据每个fd上面的callbac函数实现的，只有活跃的socket才会去主动调用callback函数，epoll实现了一个伪AIO）
 3. select、poll和 epoll 需要内核把FD消息通知给用户空间。epoll 是通过内核和用户空间mmap同一块内存来实现的
 4. epoll API更加简单。创建一个 epoll描述符、添加监听事件、阻塞等待所监听的事件发生、关闭 epoll描述符。

#### 信号驱动式I/O（SIGIO）
![netty](/img/netty/netty5.jpg)

#### 异步I/O（POSIX的 aio_系列函数）
告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。注意红线标记处说明在调用时就可以立马返回，等函数操作完成会通知我们
![netty](/img/netty/netty6.jpg)



#### 主要观点
其实前四种I/O模型（阻塞式I/O、非阻塞式I/O、I/O复用和信号驱动式I/O）都是同步I/O操作，他们的区别在于第一阶段，而他们的第二阶段是一样的：在数据从内核复制到应用缓冲区期间（用户空间）时，进程阻塞于recvfrom调用。

在处理 IO 的时候，阻塞和非阻塞都是同步IO。只有使用了特殊的 API 才是异步 IO。
![netty](/img/netty/netty1.jpg)

Epoll应该是同步的。属于IO多路复用的一种（IO多路复用还有一个名字叫做事件驱动。但从高层(业务层次)来看是异步的。

