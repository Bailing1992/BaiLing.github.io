---
layout: post
title: "RocketMQ 系列 生产者"
subtitle: '刨析rocketMQ的底层实现'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - rocketMQ
---

RocketMQ 发送普通消息有三种实现方式：
* 可靠同步发送
* 可靠异步发送
* 单向(Oneway）发送。

## 概念
#### 故障延迟机制
消息发送端采用重试机制，选择消息队列有两种方式。   
**获取机制**    
直接用sendWhichQueue 自增再获取值， 与当前路由表中消息队列个数取模， 返回该位置的MessageQueue。
如果消息发送再失败的话，下次进行消息队列选择时规避上次MesageQueue 所在的Broker， 否则还是很有可能再次失败。

#### 消息消费模式：
广播模式与集群模式:
* 广播模式比较简单，每一个消费者需要去拉取订阅主题下所有消费队列的消息
* 在集群模式下，同一个消费组内有多个消息消费者，同一个主题存在多个消费队列，那么消费者进行消息队列负载.
## 问题
#### 消息队列如何进行负载？
根据*路由信息*选择消息队列，返回的消息队列按照broker 、序号排序。
消息队列负载，通常的做法是一个消息队列在同一时间只允许被一个消息消费者消费，一个消息消费者可以同时消费多个消息队列.

消息发送端采用重试机制.
#### 消息发送如何实现高可用？
#### 批量消息发送如何实现一致性？


#### consumer的业务消费代码一定要保证幂等的原因？
1. 由于先消费消息，再提交offset，因此可能存在消费完消息之后，提交offset失败；当然这种可能性极低（因为消费完之后提交offset只是做了内存操作）
2. 由于offset是先存在内存中，定时器间隔几秒提交给broker，消费之后的offset是完全存在可能丢失的风险（例如consumer端突然宕机），从而会导致没有提交offset到broker，再次启动consumer客户端时，会重复消费。

#### 消费消息失败了是怎么实现重试的？