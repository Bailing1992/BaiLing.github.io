---
layout: post
title: "RocketMQ 系列 消息中间件基本问题"
subtitle: '消息中间件基本问题'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - rocketMQ
---

## Publish/Subscribe
发布订阅是消息中间件 的最基本功能，也是相对于传统 RPC 通信而言。在此不再详述

## Message Priority
规范中描述的优先级是指在一个消息队列中，每条消息都有不同的优先级，一般用整数来描述，优先级高的消息先投递，如果消息完全在一个内存队列中，那么在投递前可以按照优先级排序，令优先级高的先投递。

由于 RocketMQ 所有消息都是持久化的，所以如果按照优先级来排序，开销会非常大，因此 RocketMQ 没有特意支持消息优先级，但是可以通过变通的方式实现类似功能，即单独配置一个优先级高的队列，和一个普通优先级的队列， 将不同优先级发送到不同队列即可。

对于优先级问题，可以归纳为 2 类：
1. 只要达到优先级目的即可，不是严格意义上的优先级，通常将优先级划分为高、中、低，或者再多几个级别。每个优先级可以用不同的 topic 表示，发消息时，指定不同的 topic 来表示优先级，这种方式可以解决。绝大部分的优先级问题，但是对业务的优先级精确性做了妥协

2. 严格的优先级，优先级用整数表示，例如 0 ~ 65535 ，这种优先级问题一般使用 不同 topic 解决就非常不合适。如果要让 MQ 解决此问题，会对 MQ 的性能造成非常大的影响。这里要确保一点，业务上是否确实需要这种严格的优先级，如果 将优先级压缩成几个，对业务的影响有多大

## Message Order

消息有序指的是一类消息消费时，能按照发送的顺序来消费。例如：一个订单产生了
3 条消息，分别是订单创
建，订单付款，订单完成。消费时，要按照这个顺序消费才能有意义。但是同时订单之间是可以并行消费的。
RocketMQ 可以严格的保证消息有序。

## Message Filter
* Broker 端消息过滤
在 Broker 中，按照 Consumer 的要求做过滤，优点是减少了对于 Consumer 无用消息的网络传输。缺点是增加了Broker 的负担 ，实现相对复杂。
1. 淘宝 Notify 支持多种过滤方式，包含直接按照消息类型过滤，灵活的语法表达式过滤，几乎可以满足最苛刻的过滤需求。
2. 淘宝 RocketMQ 支持按照 简单的 Message Tag 过滤，也支持按照 Message Header 、 body 进行过滤。
3. CORBA Notification 规范中也支持灵活的语法表达式过滤。
*  Consumer 端消息过滤
这种过滤方式可由应用完全自定义实现，但是缺点是很多无用的消息要传输到
Consumer 端。

## Message Persistence
消息中间件通常采用的几种持久化方式：
1. 持久化到数据库，例如 MySQL。
2. 持久化到 KV 存储，例如 levelDB 、伯克利 DB 等 KV 存储系统。
3. 文件记录形式持久化，例如 Kafka RocketMQ
4. 对内存数据做一个持久化镜像，例如 beanstalkd VisiNotify

1.2.3 三种持久化方式都具有将内存队列 Buffer 进行扩展的能力，4 只是一个内存的镜像，作用是当 Broker 挂掉重启后仍然能将之前内存的数据恢复出来。

JMS 与 CORBA Notification 规范没有明确说明如何持久化，但是持久化部分的性能直接决定了整个 消息中间件的性能。

RocketMQ 参考了 Kafka 的持久化方式，充分利用 Linux 文件系统内存 cache 来提高性能。

##  Message Reliablity

影响消息可靠性的几种情况：
1. Broker 正常关闭
2. Broker 异常 Crash
3. OS Crash
4. 机器掉电，但是能立即恢复供电情况。
5. 机器无法开机（可能是 cpu 、主板、内存等关键设备损坏）
6. 磁盘设备损坏。

1、2、3、4 四种情况都属于硬件资源可立即恢复情况， RocketMQ 在这四种情况下能保证消息不丢，或
者丢失少量数据（依赖刷盘方式是同步还是异步）。
(5)
、 ( 属于单点故障，且无法恢复，一旦发生，在此单点上的消息全部丢失。 RocketMQ 在这两种情况下，通
过异步复制，可保证 99% 的消息不丢，但是仍然会有极少量的消息可能丢失。通过同步双写技术 可以 完全避免单点，
同步双写势必会影响性能，适合对消息可靠性要求极高的场合，例如与 Money 相关的应用。
RocketMQ。

从 3.0 版本开始支持同步双写。

##  Low Latency Messaging

在消息不堆积情况下，消息到达 Broker 后，能立刻到达 Consumer。

RocketMQ 使用长轮询 Pull 方式，可保证消息非常实时，消息实时性不低于 Push。

## At least Once
是指每个消息必须投递一次。
RocketMQ Consumer 先 pull 消息到本地，消费完成后，才向服务器反回 ack，如果没有消费一定不会 ack 消息，
所以 RocketMQ 可以很好的支持此特性。

## Exactly Only Once
1. 发送消息阶段，不允许发送重复的消息
2. 消费消息阶段，不允许消费重复的消息
只有以上两个条件都满足情况下，才能认为消息是“Exactly Only Once”，而要实现以上两点，在分布式系统环境下，不可避免要产生巨大的开销。所以 RocketMQ 为了追求高性能，并不保证此特性，要求在业务上迕行去重，也就是说消费消息要做到幂等性。RocketMQ 虽然不能严格保证不重复，但是正常情况下很少会出现重复发送、消费情况，只有网络异常，Consumer 启停等异常情冴下会出现消息重复。

此问题的本质原因是网络调用存在不确定性，即既不成功也不失败的第三种状态，所以才产生了消息重复性问题。

## Broker 的 Buffer 满了怎么办

## 回溯消费
回溯消费是指 Consumer 已经消费成功的消息，由于业务上需求需要重新消费，要支持此功能，Broker 在向 Consumer 投递成功消息后，消息仍然需要保留。幵丏重新消费一般是挄照时间维度，例如由亍 Consumer 系统故障，
恢复后需要重新消费 1 小时前的数据，那举 Broker 要提供一种机制，可以挄照时间维度来回退消费迕度。
RocketMQ 支持挄照时间回溯消费，时间维度精确到毫秒，可以吐前回溯，也可以吐后回溯。