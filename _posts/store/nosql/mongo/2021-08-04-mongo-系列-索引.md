---
layout: post
title: "Mongo 索引"
subtitle: '开启 MongoDB 学习新篇章'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - mongo 
---

> 索引可以用来优化查询，为集合选择合适的索引是提升性能的关键。

使用 ```expalin()``` 函数查看在执行查询的过程中所做的事情。MongoDB 3.0+ 的 explain 有三种模式，分别是：queryPlanner、executionStats、allPlansExecution。现实开发中，常用的是 executionStats 模式，主要分析这种模式。

```javascript
> db.blog.find( { "$or" : [{"title": {"$gt": "my", "$lte": "my blog title"}}, {"votes" : 2}]}).explain("executionStats")

```
```javascript
{
	// queryPlanner 显示被查询优化器选择的查询计划
	"queryPlanner" : {
		"plannerVersion" : 1,
		// namespace 返回的是该 query 所查询的表
		"namespace" : "test.blog",
		"indexFilterSet" : false,
		"parsedQuery" : {
			"$or" : [
				{
					"$and" : [
						{
							"title" : {
								"$lte" : "my blog title"
							}
						},
						{
							"title" : {
								"$gt" : "my"
							}
						}
					]
				},
				{
					"votes" : {
						"$eq" : 2
					}
				}
			]
		},
		// 查询优化器针对该query所返回的最优执行计划的详细内容
		"winningPlan" : {
			// 最优执行计划的 stage
			"stage" : "SUBPLAN",
			// 用来描述子 stage，并且为其父 stage 提供文档和索引关键字
			"inputStage" : {
				"stage" : "FETCH",
				"inputStage" : {
					"stage" : "OR",
					"inputStages" : [
						{
							"stage" : "IXSCAN",
							// 所扫描的index内容
							"keyPattern" : {
								"title" : 1
							},
							// 所选用的index
							"indexName" : "title_1",
							// 是否是Multikey，此处返回是false，如果索引建立在array上，此处将是true
							"isMultiKey" : false,
							"multiKeyPaths" : {
								"title" : [ ]
							},
							"isUnique" : false,
							"isSparse" : false,
							"isPartial" : false,
							"indexVersion" : 2,
							// 此query的查询顺序，此处是forward，如果用了.sort({"title":-1})将显示backward
							"direction" : "forward",
							// 所扫描的索引范围,如果没有制定范围就是[MaxKey, MinKey]
							"indexBounds" : {
								"title" : [
									"(\"my\", \"my blog title\"]"
								]
							}
						},
						{
							"stage" : "IXSCAN",
							"keyPattern" : {
								"votes" : 1
							},
							"indexName" : "votes_1",
							"isMultiKey" : false,
							"multiKeyPaths" : {
								"votes" : [ ]
							},
							"isUnique" : false,
							"isSparse" : false,
							"isPartial" : false,
							"indexVersion" : 2,
							"direction" : "forward",
							"indexBounds" : {
								"votes" : [
									"[2.0, 2.0]"
								]
							}
						}
					]
				}
			}
		},
		// 其他执行计划（非最优而被查询优化器reject的）的详细返回
		"rejectedPlans" : [ ]
	},
	"executionStats" : {
		"executionSuccess" : true,
		// query 返回的条目
		"nReturned" : 3,
		// 该query的整体查询时间
		"executionTimeMillis" : 0,
		// 索引扫描条目, 0 表示没有用到索引
		"totalKeysExamined" : 4,
		// 文档扫描条目
		"totalDocsExamined" : 3,
		"executionStages" : {
			// FETCH 表示根据索引去检索指定 document
			// SUBPLAN 表示未使用到索引的 $or 查询
			"stage" : "SUBPLAN",
			"nReturned" : 3,
			// stage 预计执行时间
			"executionTimeMillisEstimate" : 0,
			"works" : 6,
			"advanced" : 3,
			"needTime" : 2,
			"needYield" : 0,
			"saveState" : 0,
			"restoreState" : 0,
			"isEOF" : 1,
			// 用于容纳 子stage
			"inputStage" : {
				//子stage
				"stage" : "FETCH",
				"nReturned" : 3,
				"executionTimeMillisEstimate" : 0,
				"works" : 6,
				"advanced" : 3,
				"needTime" : 2,
				"needYield" : 0,
				"saveState" : 0,
				"restoreState" : 0,
				"isEOF" : 1,
				"docsExamined" : 3,
				"alreadyHasObj" : 0,
				"inputStage" : {
					"stage" : "OR",
					"nReturned" : 3,
					"executionTimeMillisEstimate" : 0,
					"works" : 6,
					"advanced" : 3,
					"needTime" : 2,
					"needYield" : 0,
					"saveState" : 0,
					"restoreState" : 0,
					"isEOF" : 1,
					"dupsTested" : 4,
					"dupsDropped" : 1,
					"inputStages" : [
						{
							"stage" : "IXSCAN",
							"nReturned" : 1,
							"executionTimeMillisEstimate" : 0,
							"works" : 2,
							"advanced" : 1,
							"needTime" : 0,
							"needYield" : 0,
							"saveState" : 0,
							"restoreState" : 0,
							"isEOF" : 1,
							"keyPattern" : {
								"title" : 1
							},
							"indexName" : "title_1",
							"isMultiKey" : false,
							"multiKeyPaths" : {
								"title" : [ ]
							},
							"isUnique" : false,
							"isSparse" : false,
							"isPartial" : false,
							"indexVersion" : 2,
							"direction" : "forward",
							"indexBounds" : {
								"title" : [
									"(\"my\", \"my blog title\"]"
								]
							},
							"keysExamined" : 1,
							"seeks" : 1,
							"dupsTested" : 0,
							"dupsDropped" : 0
						},
						{
							"stage" : "IXSCAN",
							"nReturned" : 3,
							"executionTimeMillisEstimate" : 0,
							"works" : 4,
							"advanced" : 3,
							"needTime" : 0,
							"needYield" : 0,
							"saveState" : 0,
							"restoreState" : 0,
							"isEOF" : 1,
							"keyPattern" : {
								"votes" : 1
							},
							"indexName" : "votes_1",
							"isMultiKey" : false,
							"multiKeyPaths" : {
								"votes" : [ ]
							},
							"isUnique" : false,
							"isSparse" : false,
							"isPartial" : false,
							"indexVersion" : 2,
							"direction" : "forward",
							"indexBounds" : {
								"votes" : [
									"[2.0, 2.0]"
								]
							},
							"keysExamined" : 3,
							"seeks" : 1,
							"dupsTested" : 0,
							"dupsDropped" : 0
						}
					]
				}
			}
		}
	},
	"serverInfo" : {
		"host" : "C02CPDBCMD6M",
		"port" : 27017,
		"version" : "4.4.6",
		"gitVersion" : "72e66213c2c3eab37d9358d5e78ad7f5c1d0d0d7"
	},
	"ok" : 1
}
```

|         satge       |       解析              |
|       ---           |               ---                  |
|       COLLSCAN      |       全表扫描                      |       
|       IXSCAN	      |       扫描索引                      |
|       FETCH	      |       根据索引去检索指定 document     |
|       SHARD_MERGE   |       将各个分片返回数据进行 merge     |
|       SORT       	  |       表明在内存中进行了排序           |
|       LIMIT         |       使用 limit 限制返回数           |
|       SKIP	      |       使用 skip 进行跳过              |
|       IDHACK     	  |       针对 _id 进行查询               |
|    SHARDING_FILTER  |       通过 mongos 对分片数据进行查询     |
|       COUNT	      |       利用 db.coll.explain().count() 之类进行count 运算     |
|       COUNTSCAN  	  |       不使用 Index 进行 count         |
|       COUNT_SCAN	  |       使用 Index 进行 count           |
|       SUBPLA    	  |       未使用到索引的 $or 查询           |
|       TEXT	      |       使用全文索引进行查询              |
|       PROJECTION 	  |       限定返回字段                     |




对于普通查询，希望看到 stage 的组合(查询的时候尽可能用上索引):
* Fetch + IDHACK
* Fetch + ixscan
* Limit+（Fetch + ixscan）
* PROJECTION + ixscan
* SHARDING_FITER + ixscan
* COUNT_SCAN

不希望看到包含如下的 stage:
* COLLSCAN(全表扫描)
* SORT(使用 sort 但是无 index)
* 不合理的 SKIP
* SUBPLA(未用到 index 的 $or)
* COUNTSCAN(不使用 index 进行 count)


#### 查询优化器

MongoDB 查询优化器与其他数据库的稍微不同。基本来说，如果一个索引能够精确匹配一个查询，那么查询优化器就会使用这个索引，如果不能精确匹配，可能会有几个索引都适合查询。那MongoDB是怎样选择的呢？答：MongoDB的查询计划会将多个索引并行的去执行，最早返回100个结果的就是胜者，其他查询计划都会被终止。

这个查询计划会被缓冲，接下来的这个查询都会使用它，下面几种情况会重新计划：
* 最初的计划评估之后集合发生了比较大的数据波动，查询优化器就会重新挑选可行的查询计划
* 建立索引时
* 每执行 1000 次查询之后，查询优化器就会重新评估查询计划
#### 索引
> 索引可以根据给定的字段组织数据, 让 MongoDB 能够非常快地找到目标数据。

对于添加的每一个索引，每次写操作（插入、更新、删除）都将耗费更多的时间，因为当数据发生变动时，MongoDB不仅要更新文档，还要更新集合上的所有索引。

MongoDB 限制每个集合上最多只能有 64 个索引。

###### 查询索引
查看集合中的索引

```javascript
> db.blog.getIndexs()
```
为了优化查询，可将查询结果限制为 1，这样 MongoDB 在找到一个文档之后就会停止了。

```javascript
> db.blog.find({"title":"my blog title"}).limit(1).explain("executionStats")

```
###### 创建索引
在字段上创建索引，1(升序); -1(降序)。索引可以在任何类型的字段，甚至文档。
当系统已有大量数据时，创建索引就是个非常耗时的活，```{background:true}``` 表示在后台执行。
```javascript
> db.blog.ensureIndex({"title": 1}, {background:true})


{
	"createdCollectionAutomatically" : false,
	"numIndexesBefore" : 1,
	"numIndexesAfter" : 2,
	"ok" : 1
}
```

复合索引(又名组合索引，建立在多个字段上的索引)，当创建组合索引时，字段后面的 1 表示升序，-1 表示降序，是用 1 还是用 -1 主要是跟排序或指定范围查询有关。
```javascript
> db.blog.ensureIndex({"title": 1, "votes": 1})

```
唯一索引，指定```{unique:true}```即可创建唯一索引。某一个字段为 null，或不存在这个字段，都被处理为 null，已有数据存在相同的数值，会报重复键值异常。

```javascript
> db.blog.ensureIndex({"title": 1}, {unique:true} )

```
###### 使用索引

使用索引键对文档进行排序非常高效

```javascript
> db.blog.find().sort({"title": 1, "votes": 1})

```

```hint``` 命令可以强制使用某个索引。

```javascript
> db.blog.find().sort({"title": 1, "votes": 1}).hint({"title":1, "votes":1}

```

MongoDB 可以在任意方向上对索引进行遍历

```javascript
> db.blog.find({"title": "my blog title"}).sort({"votes": -1})
```

这是一个点查询，用于查找单个值（尽管这个值的文档可能有多个），由于索引中的第二个字段，查询结果已经是有序的了，MongoDB可以从匹配的最后一个索引开始，逆序依次遍历索引。


```javascript
> db.blog.find({"title": {"$gt": "my", "$lte": "my blog title"}})
```
这是一个多值查询，利用索引的第一个键查找到多个值相匹配的文档。通常来说，如果 MongoDB 使用索引进行查询，那么查询结果文档通常是按照索引顺序排列的。

```javascript
> db.blog.find({"title": {"$gt": "my", "$lte": "my blog title"}}).sort({"votes": -1})
```

使用索引得到的结果集中 ```votes``` 是无序的，所以 MongoDB 需要先在内存中对结果进行排序，然后才能返回。（如果结果集的大小超过 32MB，MongoDB就会出错，拒绝对如此多的数据进行排序）。

```hint``` 强制 MongoDB 使用某个特定的索引

```javascript
> db.blog.find({"title": {"$gt": "my", "$lte": "my blog title"}}).sort({"votes": -1}).hint({"title":1, "votes":1}).explain("executionStats")
```

在基于多个查询条件进行排序时，索引方向比较重要，需保证索引方向和排序方向相同。相互反转（在每个方向都乘以-1）的索引是等价的：```{"title": 1, "votes": -1}``` 适合的查询与 ```{"title": -1, "votes": 1}``` 是完全一样的。

为了使用覆盖索引，需要使用投射来指定不要返回 ```_id``` 字段。

如果在一个含有数组的字段上做索引，这个索引永远也无法覆盖查询（因为数组是被保存在索引中的）。即便将数组字段从需要返回的字段中剔除，这样的索引也无法覆盖查询。

###### 删除索引

删除表中的所有索引
```javascript
db.blog.dropIndexes()
```

删除表中的某个索引

```javascript
db.blog.dropIndex("title_1")
```

###### 低效查询
【禁止使用】```$where``` 查询无法使用索引。
 
【禁止使用】检查一个键是否存在的查询 ```{"key":{"$exists":true}}``` 无法使用索引，在索引中，不存在的字段和 null 字段的存储方式是一样的，查询必须遍历每一个文档检查这个值是否真的为 null 还是根本不存在。

【不建议使用】```$ne``` 取反查询可以使用索引，但是效率比较低，因为必须要查看所有的索引条目，而不只是 ```$ne``` 指定的条目，不得不扫描整个索引。


```javascript
> db.blog.find({"title": {"$ne": "my blog title"}}).explain("executionStats")

```

【不建议使用】 ```$not``` 有时能够使用索引，但是通常并不知道如何使用索引，所以大多数使用 ```$not``` 的查询都会退化为 进行全表扫描。

```javascript
> db.blog.find({"votes": {"$not": {"$gt":1}}}).explain("executionStats")

```


```$in``` 可以使用索引


```javascript
> db.blog.find({"votes": {"$in":[-1,2]}}).explain("executionStats")

```

```$nin``` 也可以使用索引。

```javascript
> db.blog.find({"votes": {"$nin":[-1,2]}}).explain("executionStats")

```


> 查询中的字段顺序无关紧要，MongoDB会自动找出可以使用索引的字段，而无视查询中的字段顺序。

设计基于多个字段的索引时，应该将会用于精确匹配的字段放在索引的前面，将用于范围匹配的字段放在后面。这样查询就可以先使用第一个索引键进行精确查询，然后再使用第二个索引范围在这个结果集内部进行搜索。


例如在 ```{ "title": 1, votes: 1}``` 索引下，下面查询会定位到  "title" 为 "my blog title" 的索引条目，然后在结果集中搜索 votes 区间

```javascript
> db.blog.find({"title":  "my blog title", "votes":{"$gt":1, "$lt" :2 }}).explain("executionStats")


{
	"executionStats" : {
			"inputStage" : {
					"indexBounds" : {
						"title" : [
							"[\"my blog title\", \"my blog title\"]"
						],
						"votes" : [
							"(1.0, 2.0)"
						]
				},
			}
	}
}
```


```javascript
> db.blog.find({"title": {"$gt": "my", "$lte": "my blog title"}, "votes":2}).explain("executionStats")


{
	"executionStats" : {
			"inputStage" : {
					"indexBounds" : {
						"title" : [
							"(\"my\", \"my blog title\"]"
						]
				},
				},
			}
	}
}
```


```$or``` 可以对每个字句都使用索引，因为```$or```实际上是执行两次查询然后将结果集合并（剔除重复的文档）。通常来说，执行两次查询将结果合并的效率不如单次查询高，因此，应该尽可能使用```$in``` 而不是 ```$or```。

```javascript
> db.blog.find( { "$or" : [{"title": {"$gt": "my", "$lte": "my blog title"}}, {"votes" : 2}]}).explain("executionStats")


{
	"executionStats" : {
			"inputStage" : {
				"inputStage" : {
					"inputStage" : [
					{
						"stage" : "IXSCAN",
						"nReturned" : 1,
						"executionTimeMillisEstimate" : 0,
						"works" : 2,
						"advanced" : 1,
						"needTime" : 0,
						"needYield" : 0,
						"saveState" : 0,
						"restoreState" : 0,
						"isEOF" : 1,
						"keyPattern" : {
							"title" : 1
						},
						"indexName" : "title_1",
						"isMultiKey" : false,
						"multiKeyPaths" : {
							"title" : [ ]
						},
						"isUnique" : false,
						"isSparse" : false,
						"isPartial" : false,
						"indexVersion" : 2,
						"direction" : "forward",
						"indexBounds" : {
							"title" : [
								"(\"my\", \"my blog title\"]"
							]
						},
						"keysExamined" : 1,
						"seeks" : 1,
						"dupsTested" : 0,
						"dupsDropped" : 0
					},
					{
						"stage" : "IXSCAN",
						"nReturned" : 3,
						"executionTimeMillisEstimate" : 0,
						"works" : 4,
						"advanced" : 3,
						"needTime" : 0,
						"needYield" : 0,
						"saveState" : 0,
						"restoreState" : 0,
						"isEOF" : 1,
						"keyPattern" : {
							"votes" : 1
						},
						"indexName" : "votes_1",
						"isMultiKey" : false,
						"multiKeyPaths" : {
							"votes" : [ ]
						},
						"isUnique" : false,
						"isSparse" : false,
						"isPartial" : false,
						"indexVersion" : 2,
						"direction" : "forward",
						"indexBounds" : {
							"votes" : [
								"[2.0, 2.0]"
							]
						},
						"keysExamined" : 3,
						"seeks" : 1,
						"dupsTested" : 0,
						"dupsDropped" : 0
					}
					]
				},
			},
		}

}

```

