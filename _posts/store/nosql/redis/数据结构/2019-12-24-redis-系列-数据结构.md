---
layout: post
title: "redis 系列 数据结构"
subtitle: '总结redis中涉及的数据结构'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - redis 
---

> Redis 有 5 种基础数据结构，分别为 string 字符串，list 列表，set 集合，hash 哈希，zset 有序集合。 Redis 里面的每一种数据结构不止有一种底层实现，在不同的场景下Redis 会使用不同的底层实现，例如 zset，在元素个数不超过 64 时采用压缩列表实现，否则采用*跳表+哈希表*实现。

## string 字符串

Redis 字符串是简单动态字符串，是可以修改的字符串，内部结构实现上类似于 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配，如下图所示，内部为当前字符串实际分配的空间 capacity 一般要高于实际字符串长度 len。当字符串长度小于 1M 时，扩容都是加倍现有的空间，如果超过 1M，扩容时一次只会多扩 1M 的空间。需要注意的是字符串最大长度为 512 M。

![动态字符串](/img/redis/string.png)

> 键值对的键是一个字符串对象，值可能是一个字符串对象。Redis 所有的数据结构都是以唯一的 key 字符串作为名称，然后通过这个唯一 key 值来获取相应的 value 数据。不同类型的数据结构的差异就在于 value 的结构不一样。

[详情请看zset有序集合](https://bailing1992.github.io/2019/12/24/redis-%E7%B3%BB%E5%88%97-%E5%AD%97%E7%AC%A6%E4%B8%B2/)

## list 列表
在版本 3.2 之前，Redis 列表数据结构的底层实现是 ziplist 和 linkedlist，当列表对象中元素的长度比较小并且数量比较少的时候，采用 ziplist 来存储，当列表对象中元素的长度比较大或者数量比较多的时候，则会转而使用双向列表 linkedlist 来存储。

在版本 3.2 之后，引入了一个 quicklist 的数据结构，列表的底层都由 quicklist 实现。在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 ziplist，也即是压缩列表。当数据量比较多的时候才会改成快速链表（quicklist）。Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。
![快速列表简易图](/img/redis/快速列表简易图.png)

> 两种存储方式的优缺点：
* 双向链表 linkedlist 便于在列表的两端进行 push 和 pop 操作，在插入节点上复杂度很低，但是它的内存开销比较大。首先，它在每个节点上除了要保存数据之外，还要额外保存两个指针；其次，双向链表的各个节点是单独的内存块，地址不连续，节点多了容易产生内存碎片。
* ziplist 存储在一段连续的内存上，所以存储效率很高。但是修改操作、插入和删除操作需要频繁的申请和释放内存。特别是当 ziplist 长度很长的时候，一次 realloc 可能会导致大批量的数据拷贝。

[详情请看压缩列表](https://bailing1992.github.io/2019/12/24/redis-%E7%B3%BB%E5%88%97-%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8/)

[详情请看快速列表](https://bailing1992.github.io/2019/12/24/redis-%E7%B3%BB%E5%88%97-%E5%BF%AB%E9%80%9F%E5%88%97%E8%A1%A8/)

## hash字典
Redis 字典相当于 Java 语言里面的 HashMap，它是无序字典。内部实现结构上同 Java 的 HashMap 也是一致的，同样的数组 + 链表二维结构。第一维 hash 的数组位置碰撞时，就会将碰撞的元素使用链表串接起来。
![存储概览](/img/redis/4.png)
不同的是，Redis 的字典的值只能是字符串，另外它们 rehash 的方式不一样，因为 Java 的 HashMap 在字典很大时，rehash 是个耗时的操作，需要一次性全部 rehash。Redis 为了高性能，不能堵塞服务，所以采用了渐进式 rehash 策略。
![存储概览](/img/redis/3.png)

渐进式 rehash 会在 rehash 的同时，保留新旧两个 hash 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务中以及 hash 的子指令中，循序渐进地将旧 hash 的内容一点点迁移到新的 hash 结构中。

## set集合

Redis的集合相当于Java语言里面的HashSet，它内部的键值对是无序的、唯一的。它的内部实现相当于一个特殊的字典，字典中所有的value都是一个值NULL。

## zset有序集合
```zset``` 底层实现使用了两个数据结构，第一个是 hash，第二个是跳跃列表，hash 的作用就是关联元素 value 和权重 score，保障元素 ```value``` 的唯一性，可以通过元素 value 找到相应的 score 值。跳跃列表的目的在于按照score给元素 value 排序，根据 score 的范围获取元素value列表。

![存储概览](/img/redis/zset存储结构.png)

[详情请看zset有序集合](https://bailing1992.github.io/2019/12/24/redis-%E7%B3%BB%E5%88%97-%E8%B7%B3%E8%B7%83%E5%88%97%E8%A1%A8/)
