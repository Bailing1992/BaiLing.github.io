---
layout: post
title: "存储 系列 数据模型"
subtitle: '...'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - store
---
> 在可预见的将来，关系数据库可能仍将继续与各种非关系数据存储一起使用，这种思路有时也被称为混合持久化。

## 数据模型
#### 关系模型（SQL）
关系模型中数据被组织成关系（relations），在SQL中称为表（table），其中每个关系都是元组(tuples）的无序集合（在SQL中称为行）。

对采用面向对象编程语言开发的应用来说，如果数据存储在关系表中， 那么应用层代码中的对象与表、行和列的数据库模型之间需要一个转换层。对象－关系映射（ORM）框架减少了此转换层所需的样板代码量，但是他们并不能完全隐藏两个模型之间的差异。

关系模型的目标就是将实现细节隐藏在更简洁的接口（SQL）后面。

#### NoSQL（不仅仅是SQL）

NoSQL 数据库比关系数据库更好的扩展性需求，包括支持超大数据集或超高写入吞吐量。

#### 文档数据模型
文档数据模式的优势是灵活性，由于局部性而带来较好的性能，对于某些应用来说，它更接近于应用程序所使用的数据结构。
文档数据模式的局限性是不能直接引用文档中的嵌套项

MongoDB

## 数据查询语言
#### 命令式查询语言
命令式语言告诉计算机以特定顺序执行某些操作。
#### 声明式查询语言
声明式查询语言（如SQL或关系代数），则只需指定所需的数据模式，结果需满足什么条件，以及如何转换数据（例如，排序、分组和聚合），而不需指明如何实现这一目标。数据库系统的查询优化器会决定采用哪些索引和联结，以及用何种顺序来执行查询的各个语句。
#### MapReduce查询
MapReduce 是一种编程模型，用于在许多机器上批量处理海量数据。MapReduce 既不是声明式查询语言，也不是一个完全命令式的查询API，而是介于两者之间：查询的逻辑用代码片段来表示， 这些代码片段可以被处理框架重复地调用。它主要基于许多函数式编程语言中的map（ 也称为collect）和reduce（也称为fold或 inject）函数。

Map 和 Reduce 函数对于可执行的操作有所限制。它们必须是纯函数，这意味着只能使用传递进去的数据作为输入，而不能执行额外的数据库查询，也不能有任何副作用。这些限制使得数据库能够在任何位置、以任意顺序来运行函数，并在失败时重新运行这些函数。不管怎样，该功能非常强大，可以通过它来解析字符串、调用库函数、执行计算等。

## 存储引擎
存储引擎主要有两个存储引擎家族，即日志结构的存储引擎和面向页的存储引擎，比如B-tree。分别用于大家比较熟悉的两种数据库，即传统的关
系数据库和大多数所谓的NoSQL数据库。


#### 日志存储引擎
通常做法是日志分解成一定大小的段，当文件达到一定大小时就关闭它，并将后续写入到新的段文件中。可以在日志段上执行压缩。压缩意味着在日志中丢弃重复的键，并且只保留每个键最近的更新。

> 优点：
    1.  追加和分段合并主要是顺序写，它通常比随机写入快得多
    2.  合并旧段可以避免随着时间的推移数据文件出现碎片化的问题。

###### 日志压缩
每个段都有自己的内存哈希表，将键映射到文件的偏移量。为了找到键的值，首先检查最新的段的hash map。如果键不存在，检查第二最新的段，以此类推。、

>  对于这些冻结段的合井和压缩过程可以在后台线程中完成，而且运行时，仍然可以用旧的段文件继续正常读取和写请求。当合并过程完成后，将读取请求切换到新的合并段上，而旧的段文件可以安全删除。

###### 文件格式
通常采用二进制格式，首先以字节为单位来记录字符串的长度，之后跟上原始字符串（不需要转义）

###### 删除记录
如果要删除键和它关联的值，则必须在数据文件中追加一个特殊的删除记录。
###### 崩溃恢复

如果数据库重新启动，则内存中的hash map将丢失。原则上，可以通过从头到尾读取整个段文件，然后记录每个键的最新值的偏移量，来恢复每个段的hash
map。但是，如果分段文件很大，可能扫描需要很长时间，这将使服务器重启变得缓慢。优化方案是通过将每个段的hash map的快照存储在磁盘上，可以更快地加载
到内存中，以此加快恢复速度。

###### 并发控制
由于写入以严格的先后顺序追加到日志中，通常的实现选择是只有一个写线程。数据文件段是追加的， 并且是不可变的， 所以他们可以被多个线程同时读取。

#### LSM-tree存储引擎
基于合并和压缩排序文件原理的存储引擎通常都被称为LSM存储引擎。LSM思想基于保存在系统中的一系列排序字符串表（SSTable）

排序字符串表（SSTable）算法本质上正是LevelDB和RocksDB所使用的，主要用于嵌入到其他应用程序的key-value存储引擎库。排序字符串表要求key-value对的顺序按键排序，也要求每个键在每个合并的段文件中只能出现一次（压缩过程已经确保了）。存储引擎的基本工作流程如下：
1. 当写入时，将其添加到内存中的平衡树数据结构中（列如红黑树）。这个内存中的树有时被称为内存表。
2. 当内存表大于某个阈值（通常为几兆字节）时，将其作为SSTable文件写入磁盘。由于树已经维护了按键排序的key-value对，写磁盘可以比较高效。新的SSTable文件成为数据库的最新部分。当SSTable写磁盘的同时，写入可以继续添加到一个新的内存表实例。
3. 为了处理读请求，首先尝试在内存表中查找键，然后是最新的磁盘段文件，接下来是次新的磁盘段文件，以此类推，直到找到目标（或为空）。
4. 后台进程周期性地执行段合并与压缩过程，以合并多个段文件，并丢弃那些已被覆盖或删除的值。

> 优点：
  1. 合并段更加简单高效，即使文件大于可用内存。方法类似于合并排序算法中使用的方法。
  2. 查找更加高效，在文件中查找特定键时，不再需要在内存中保存所有键的索引。
  3. 数据集远远大于可用内存，它仍然能够正常工作
  4. 由于数据按排序存储，因此可以有效地执行区间查询
  5. 由于磁盘是顺序写入的，所以LSM-tree可以支持非常高的写入吞吐量

> 内存排序有很多广为人知的树状数据结构，例如红黑树或AVL树。使用这些数据结构，可以按任意顺序插入键并以排序后的顺序，读取它们。

> 存储引擎处理查找某个不存在键时低效的处理办法：使用额外的布隆过滤器（布隆过滤器是内存高效的数据结构，用于近似计算集合的内容。如果数据库中不存在某个键，它能够
很快告诉你结果，从而节省了很多对于不存在的键的不必要的磁盘读取）
#### 面向页的存储引擎
B-tree是最广泛使用的索引结构，是几乎所有关系数据库中的标准索引实现。

B-tree将数据库分解成固定大小的块或页，传统上大小为4KB（有时更大），页是内部读／写的最小单元。这种设计更接近底层硬件，因为磁盘也是以固定大小的块排列。

> 预写日志（write-ahead log, WAL），也称为重做日志。这是一个仅支持追加修改的文件，每个B-tree的修改必须先更新WAL然后再修改树本身的页。当数据库在崩
愤后需要恢复时，该日志用于将B-tree恢复到最近一致的状态。

> 写时复制方案: 修改的页被写入不同的位置，树中父页的新版本被创建，并指向新的位置。

#### 比较优缺点
* B-tree 索引必须至少写两次数据：一次写入预写日志，－次写入树的页本身。
* 由于反复压缩和SSTable的合井， 日志结构索引（LSM-tree）也会重写数据多次
* LSM-tree通常能够承受比B-tree更高的写入吞吐量，部分是因为它们有时具有较低的写放大。部分原因是它们以顺序方式写入紧凑的SSTable文件， 而不必重写树中的多个页。
* LSM-tree可以支持更好地压缩，因此通常磁盘上的文件比B-tree小很多
* 日志结构存储（LSM-tree）的缺点是压缩过程有时会干扰正在进行的读写操作。日志结构化存储引擎（LSM-tree）的查询晌应时间有时会相当高，而B-tree的响应延迟则更具确定
性。
* B-tree的优点则是每个键都恰好唯一对应于索引中的某个位置，而日志结构的存储引擎可能在不同的段中具有相同键的多个副本
* 在许多关系数据库中，事务隔离是通过键范围上的锁来实现的，井且在B-tree索引中，这些锁可以直接定义到树中。

> 写放大: 在数据库内，由于一次数据库写入请求导致的多次磁盘写

## 索引
为了高效地查找数据库中特定键的值，需要新的数据结构： 索引。
索引背后的基本想法都是保留一些额外的元数据，这些元数据作为路标，帮助定位想要的数据。
如果希望用几种不同的方式搜索相同的数据，在数据的不同部分，我们可能定义多种不同的索引。

索引是基于原始数据派生而来的额外数据结构。很多数据库允许单独添加和删除索引，而不影响数据库的内容，它只会影响查询性能。
维护额外的结构势必会引入开销，特别是在新数据写入时。对于写入，它很难超过简单地追加文件方式的性能，因为那已经是最简单的写操作了。
由于每次写数据时，需要更新索引，因此任何类型的索引通常都会降低写的速度。

#### 哈希索引
假设数据存储采用追加式日志文件组成。那么最简单的索引策略是：保存内存中的hash map，把每个键一一映射到数据文件中特定的字节偏移量，
这样就可以找到每个值的位置。每当在文件中追加新的key-value时，需更新hash map来反映刚刚写入数据的偏移量（包括插入新的键和更新已有的
键）。当查找某个值时，使用hash map来找到文件中的偏移量，即存储位置，然后读取其内容。

> 缺点：
  1. 哈希表必须全部放入内存。如果hash map在磁盘上，会需要大量的随机访问I/O ，当哈希变满时，继续增长代价昂贵，井且哈希冲突时
需要复杂的处理逻辑。
  2. 区间查询效率不高
#### B-tree
