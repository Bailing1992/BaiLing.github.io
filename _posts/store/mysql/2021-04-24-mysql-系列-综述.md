---
layout: post
title: "MySQL 系列 综述"
subtitle: '尽可能全面的覆盖 MySQL 涉及的内容'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---
## MySQL 基础架构及各个模块的作用
MySQL 可以分为 Server 层和存储引擎层两部分。

Server 层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。
#### MySQL 的特点
* 单进程多线程架构
* 插件式的表存储引擎
* 开源
#### Innodb 存储引擎的特点
* 其设计目标主要面向在线事务处理（OLTP）的应用         
* 完整支持 ACID 事物，实现 SQL 标准的 4 中隔离级别
* **行锁设计** 
* **支持外键** 
* 支持 MVCC（多版本并发控制，以获取高并发性）
* 采用聚集的方式存储（每张表都按主键的顺序存放）
* 支持一致性非锁定读（默认读取操作不会产生锁）
* 支持全文索引
* 支持插入缓存
* 支持二次写
* 支持自适应哈希索引
* 支持预读


## 锁
#### 如何在应用层面实现唯一性检查
可以通过 InnoDB 存储引擎的 next-key locking 机制在应用层面实现唯一性的检查。

```
 select * from table where col = XXXX lock in share mode
```
如果用户通过索引查询一个值，并对该行加上一个 SLock，即使查询的值不存在，其锁定的也是一个范围，因此如没有返回任何行，那么新插入的值一定是唯一的。
## 事务
#### Innodb 的事务与日志的实现方式
###### 事务日志有那些？
* 错误日志：记录出错信息，也记录一些警告信息或者正确的信息。
* 查询日志：记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行。
* 慢查询日志：设置一个阈值，将运行时间超过该值的所有 SQL 语句都记录到慢查询的日志文件中。
* 二进制日志：记录对数据库执行更改的所有操作。
* 中继日志：中继日志也是二进制日志，用来给 slave 库恢复
* 事务日志：重做日志 redo 和 回滚日志 undo
#### InnoDB 的可重复度隔离级别能解决缓读问题吗? 如何解决的？
InnoDB 存储引擎对于**行的查询**采用 Next-key Lock锁定算法。采用 Next-key Lock锁定技术称为 Next-key Locking，其设计的目的是为了解决幻读。利用这种锁定技术，锁定的不是单个值，而是一个范围。
## 为什么要避免长事务？
1. 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录 undo log 都必须保留，这就会导致大量占用存储空间。
2. 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。

#### 事务是如何通过日志来实现的？
事务日志是通过 redo 和 innodb 的存储引擎日志缓冲（Innodb log buffer）来实现的，当开始一个事务的时候，会记录该事务的 lsn(log sequence number) 号; 当事务执行时，会往 InnoDB 存储引擎的日志的日志缓存里面插入事务日志；当事务提交时，必须将存储引擎的日志缓冲写入磁盘（通过innodb_flush_log_at_trx_commit来控制），也就是写数据前，需要先写日志。这种方式称为“预写日志方式”
#### MySQL binlog 的几种日志录入格式以及区别
* Statement: 每一条会修改数据的 sql 都会记录在 binlog 中。
* Row: 不记录 sql 语句上下文相关信息，仅保存哪条记录被修改。
* Mixedlevel： 是以上两种 level 的混合使用，一般的语句修改使用 statment 格式保存 binlog，如一些函数，statement 无法完成主从复制的操作，则采用 row 格式保存 binlog, MySQL 会根据执行的每一条具体的 sql 语句来区分对待记录的日志形式，也就是在 Statement 和 Row 之间选择一种。
#### MySQL 数据库如何避免数据丢失（例如在数据库宕机时）
采用 write ahead log策略，即当事务提交时，先做重做日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。 
二次写：在对缓冲池的脏页进行刷盘前

#### ACID 的含义及事务隔离级别、引发的问题；
默认可重复读   
使用next-key locking的策略来避免幻读

## 主从
1. MySQL 的复制原理以及流程
基本原理流程，3个线程以及之间的关联；
  1. 主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；
  2. 从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进 自己的relay log中；
  3. 从：sql执行线程——执行relay log中的语句；

2. MySQL 中 myisam 与 innodb 的区别，至少 5 点
  1. InnoDB 支持事物，而 MyISAM 不支持事物
  2. InnoDB 支持行级锁，而 MyISAM 支持表级锁
  3. InnoDB 支持 MVCC, 而 MyISAM 不支持
  4. InnoDB 支持外键，而 MyISAM 不支持
  5. InnoDB 不支持全文索引，而 MyISAM 支持

3. Innodb 引擎的 4 大特性
  1. 插入缓冲（insert buffer),
  2. 二次写(double write),
  3. 自适应哈希索引(ahi),
  4. 预读(read ahead)
## InnoBD 的线程模型
InnoDB存储引擎是多线程模型：
* master线程（最高优先级）：负责将缓存池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新、合并插入缓存和UNDO页的回收。
* IO线程：InnoDB存储引擎中大量使用了AIO（Async IO）来处理写IO请求。IO Thread 主要工作是负责这些IO请求的回调处理。
  * insert buffer thread
  * log thread
  * read thread
  * write thread：读线程数量总是小于写线程
* purge 线程：回收已经使用并分配的undo页
* page cleaner 线程：脏页的刷新，减轻原master thread的工作
#### InnoBD 的内存模型
![内存模型](/img/mysql/bufferpool.png)
基于磁盘的数据库系统通过使用缓冲池技术来提升数据库的整体性能，将数据库文件按页读取到缓存池，借助checkpoint机制刷盘. 缓冲池中缓存的数据页类型有：
* 索引页
* 数据页
* 重做日志缓冲池：undo 页、redo log页
* 插入缓存
* 自适应哈希索引
* InnoDB 存储的锁信息
* 数据字典信息
* 额外缓冲池：提供堆内存

> 特点：数据库中的缓存池是按照（LRU）最近最少使用算法来保留缓冲池中的缓存数据；


## 使用
####  varchar 与 char 的区别以及 varchar(50) 中的 50 代表的含义
char 是一种固定长度的类型，varchar 则是一种可变长度的类型。

> 在 file sort 时，varchar 会按照 fixed_length 进行内存分配。假如有一个文本字段最多存放 50 个字符，varchar(50)和 varchar(200) 存储 “hello” 所占空间一样，但后者在排序时会消耗更多内存，因为 ```order by col``` 采用 fixed_length 计算 col 长度。

#### int（20）中 20 的含义
是指显示字符的长度
但要加参数的，最大为255，比如它是记录行数的id,插入10笔资料，它就显示00000000001 ~~~00000000010，当字符的位数超过11,它也只显示11位，如果你没有加那个让它未满11位就前面加0的参数，它不会在前面加0
20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；

#### float 和 double 的区别
  * FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。
  * DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节

#### drop、delete 与 truncate 的区别
SQL 中的 drop、delete、truncate 都表示删除，但是三者有一些差别
* delete 和 truncate 只删除表的数据不删除表的结构 
* 速度, 一般来说: drop> truncate >delete 
* delete 语句是 dml,这个操作会放到 rollback segement中,事务提交之后才生效;
* 如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.

drop、delete与 truncate 分别在什么场景之下使用
* 不再需要一张表的时候，用 drop
* 想删除部分数据行时候，用 delete，并且带上 where 子句
* 保留表而删除所有数据的时候用 truncate

#### count(*)、count(主键id)、count(字段)和 count(1)的差别
count(*)、count(主键id) 和 count(1) 都表示返回满足条件的结果集的总行数；count(字段）表示返回满足条件的数据行里面，参数“字段”不为 NULL 的总个数。
* 对于 count(主键id) 来说，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。
* 对于 count(1) 来说，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。
* count(\*) 是例外，并不会把全部字段取出来，而是专门做了优化，不取值。count(\*)肯定不是```null```，按行累加。
* 对于count(字段)来说：
  * 如果这个“字段”是定义为```not null```的话，一行行地从记录里面读出这个字段，判断不能为```null```，按行累加；
  * 如果这个“字段”定义允许为```null```，那么执行的时候，判断到有可能是```null```，还要把值取出来再判断一下，不是null才累加。

所以结论是：按照效率排序的话，count(字段) < count(主键id) < count(1)≈count(\*)，所以我建议你，尽量使用count(\*)。

#### join有什么问题？
* 如果可以使用 Index Nested-Loop Join 算法，也就是说可以用上被驱动表上的索引，其实是没问题的；
* 如果使用 Block Nested-Loop Join 算法，扫描行数就会过多。尤其是在大表上的 join 操作，这样可能要扫描被驱动表很多次，会占用大量的系统资源。所以这种join尽量不要用。

* 如果是 Index Nested-Loop Join 算法，应该选择小表做驱动表；
* 如果是 Block Nested-Loop Join 算法：
    * 在 join_buffer_size 足够大的时候，是一样的；
    * 在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。

所以，这个问题的结论就是，总是应该使用小表做驱动表。所以，更准确地说，在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与join的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。

#### group by 有什么问题？

#### 自增主键有什么问题？
只保证了自增id是递增的，但不保证是连续的。
不同的引擎对于自增值的保存策略不同:
* MyISAM 引擎的自增值保存在数据文件中。
* InnoDB 引擎的自增值，其实是保存在了内存里，并且到了 MySQL 8.0 版本后，才有了“自增值持久化”的能力，也就是才实现了“如果发生重启，表的自增值可以恢复为MySQL重启前的值”，具体情况是：
    * 在MySQL 5.7及之前的版本，自增值保存在内存里，并没有持久化。每次重启后，第一次打开表的时候，都会去找自增值的最大值max(id)，然后将max(id)+1作为这个表当前的自增值。举例来说，如果一个表当前数据行里最大的 id 是 10，AUTO_INCREMENT=11。这时候，我们删除 id=10 的行，AUTO_INCREMENT 还是11。但如果马上重启实例，重启后这个表的AUTO_INCREMENT就会变成10。也就是说，MySQL重启可能会修改一个表的AUTO_INCREMENT的值。
    * 在MySQL 8.0版本，将自增值的变更记录在了redo log中，重启的时候依靠redo log恢复重启之前的值。

自增主键不连续的可能原因：
* 唯一键冲突是导致自增主键id不连续的第一种原因
* 事务回滚也会产生类似的现象
# 相关概念
#### 数据库
文件集合，是依照某种数据模型组织起来并存放于二级存储器中的数据集合。

#### 数据库实例
数据库实例是真正用于操作数据库文件的一个进程。MySQL 为一个单进程多线程架构的数据库。

#### OLTP（联机事务处理-Online Transaction Processing）
OLTP 表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的 Transaction 以及 Execute SQL 的数量。在这样的系统中，单个数据库每秒处理的 Transaction 往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的 OLTP 系统有电子商务系统、银行、证券等，如美国 eBay 的业务数据库，就是很典型的 OLTP 数据库。

OLTP 比较常用的设计与优化方式为 Cache 技术与 B-tree 索引技术，Cache 决定了很多语句不需要从磁盘子系统获得数据，所以，Web cache 与 Oracle data buffer 对 OLTP 系统是很重要的。另外，在索引使用方面，语句越简单越好，这样执行计划也稳定，而且一定要使用绑定变量，减少语句解析，尽量减少表关联，尽量减少分布式事务，基本不使用分区技术、MV技术、并行技术及位图索引。因为并发量很高，批量更新时要分批快速提交，以避免阻塞的发生。 OLTP 系统是一个数据块变化非常频繁，SQL 语句提交非常频繁的系统。 对于数据块来说，应尽可能让数据块保存在内存当中，对于SQL来说，尽可能使用变量绑定技术来达到SQL重用，减少物理I/O 和重复的SQL 解析，从而极大的改善数据库的性能。

对比 OLAP（联机分析处理，亦即DSS决策分析系统）：就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。磁盘子系统的吞吐量则往往取决于磁盘的个数，这个时候，Cache基本是没有效果的，数据库的读写类型基本上是db file scattered read与direct path read/write。应尽量采用个数比较多的磁盘以及比较大的带宽，如4Gb的光纤接口。

## 相关命令
|  命令                                |                            释义  |
|  ----                               |           ----                   |
|```./mysqld_safe```                  | 启动数据库，在/bin目录下            |
|```mysql --help | grep my.cnf```     | MySQL 数据库实例启动时，查看配置文件的位置，会以读到的最后一个配置文件中的参数为准
|```show engines```                   | 查看支持的存储引擎                  |
|```show engine innodb status```      | 查看缓冲池的使用情况                |
|```show  create table table_name```  | 查看建表语句                       |

|```show processlist```               | 展示所有连接线程                    |
|```kill query + 线程id```             | 终止这个线程中正在执行的语句          |
|```kill connection + 线程id```        | connection 可缺省，表示断开这个线程的连接，当然如果这个线程有语句正在执行，也是要先停止正在执行的语句的。|

## 参考文献
[史上最详细的一线大厂Mysql面试题详解](https://juejin.im/post/5cb6c4ef51882532b70e6ff0)


