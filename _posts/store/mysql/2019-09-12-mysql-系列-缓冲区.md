
---
layout: post
title: "MySQL 系列 缓冲区管理"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 内存缓冲池(buffer pool) 以页为单位，缓存最热的数据页(data page)与索引页(index page)，每个数据页的大小默认为16KB。

> InnoDB 以变种 LRU（最近最少使用） 算法管理缓冲池，并能够解决“预读失效”与“缓冲池污染”的问题；

## 优化的RUL算法
缓冲池LRU数据淘汰，会将“脏页”刷回磁盘；

缓冲池采用least recently used（LRU）算法的变体，将缓冲池作为列表进行管理。
![内存模型](/img/mysql/innodb-buffer-pool-list.png)
   
在InnoDB的存储引擎中，LRU列表中加入了 midpoint位置，将列表分为两个子列表。新读取的页，虽然是最新访问的页，但并不是直接放入到 LRU列表的首部，而是存在 LRU列表的 midpoint位置。读取到mid位置后的页需要等待 innodb_old_blocks_time 时间后加入到LRU列表的热端。

> sql 操作时，仅需要缓存这次查询操作中需要的页，
 
相关参数：   
    innodb_old_blocks_time  // 移动时间.  
    innodb_old_blocks_pct  // 旧链表与新链表的长度.  

在LRU列表中的页被修改后，称该页为脏页，这时数据库会通过checkpoint机制将脏页刷新回磁盘，而flush列表中的页即为脏页列表


## 写缓冲(change buffer)
在 MySQL 5.5 之前，叫插入缓冲(insert buffer)，只针对 insert 做了优化；现在对 delete 和 update 也有效，叫做写缓冲(change buffer)。
写缓冲是降低磁盘IO，提升数据库写性能的一种机制。

它是一种应用在**非唯一普通索引页(non-unique secondary index page)**不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘 IO，提升数据库性能。

> 适用条件：非唯一普通索引页(non-unique secondary index page) : 如果索引设置了唯一(unique)属性，在进行修改操作时，InnoDB 必须进行唯一性检查。也就是说，索引页即使不在缓冲池，磁盘上的页读取无法避免(否则怎么校验是否唯一？)，此时就应该直接把相应的页放入缓冲池再进行修改。

#### 触发刷写缓冲
还有这么几种情况，会刷写缓冲中的数据：
1. 有一个后台线程，会认为数据库空闲时
2. 数据库缓冲池不够用时
3. 数据库正常关闭时
4. redo log 写满时（此时整个数据库处于无法写入的不可用状态）

#### InnoDB的写缓冲机制使用范围
先说什么时候不适合，如上文分析，当：
1. 数据库都是唯一索引
2. 或者，写入一个数据后，会立刻读取它；
这两类场景，在写操作进行时（进行后），本来就要进行进行页读取，本来相应页面就要入缓冲池，此时写缓存反倒成了负担，增加了复杂度。

什么时候适合使用写缓冲，如果：
1. 数据库大部分是非唯一索引；
2. 业务是写多读少，或者不是写后立刻读取；

可以使用写缓冲，将原本每次写入都需要进行磁盘 IO 的 SQL，优化定期批量写磁盘。


## 参数
参数：innodb_change_buffer_max_size

介绍：配置写缓冲的大小，占整个缓冲池的比例，默认值是25%，最大值是50%。

参数：innodb_change_buffering
介绍：配置哪些写操作启用写缓冲，可以设置成all/none/inserts/deletes等。

## 参考文献
[写缓冲(change buffer)，这次彻底懂了！！！](https://juejin.cn/post/6844903875271475213)
