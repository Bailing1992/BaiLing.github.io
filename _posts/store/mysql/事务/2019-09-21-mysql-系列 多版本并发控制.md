---
layout: post
title: "MySQL 系列 多版本并发控制"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---


多版本控制（Multi-Version Concurrency Control, MVCC）指的是一种提高并发的技术。

**MVCC 可以保证不阻塞地读到一致的数据。但是，MVCC 并没有对实现细节做约束，为此不同的数据库的语义有所不同，比如：Postgres 对写操作也是乐观并发控制；在表中保存同一行数据记录的多个不同版本，每次写操作，都是创建，而回避更新；在事务提交时，按版本号检查当前事务提交的数据是否存在写冲突，冲突则抛异常告知用户，回滚事务；InnoDB 则只对读无锁，写操作仍是上锁的悲观并发控制，这也意味着，InnoDB 中只能见到因死锁和不变性约束而回滚，而见不到因为写冲突而回滚。在 InnoDB 内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。。不像 Postgres 那样对数据修改在表中创建新纪录，而是每行数据只在表中保留一份，在更新数据时上行锁，同时将旧版数据写入 undo log，未提交事务会直接更新数据页上数据，回滚时使用 undo log 中的数据覆盖数据页上的数据；表和 undo log 中行数据都记录着事务ID，在检索时，只读取当前已提交的事务的行数据（读已提交和可重复读隔离级别）；可见 MVCC 中的写操作仍可以按悲观并发控制实现，而 CAS 的写操作只能是乐观并发控制。还有一个不同在于，MVCC 在语境中倾向于 “对多行数据打快照造平行宇宙”，然而 CAS 一般只是保护单行数据而已。比如 Mongodb 有 CAS 的支持，但不能说这是 MVCC。**

> 多版本并发控制是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 ***已读提交和可重复读*** 这两种隔离级别。而读未提交隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。

> MVCC 的实现方式有多种, 典型的有乐观(optimistic)并发控制 和 悲观(pessimistic)并发控制。

## 原理
MVCC 是通过保存数据在某一个时间点的快照来实现的。每开始一个新的事务，系统版本号都会自动新增。事务开始时刻的系统版本号会作为事务的版本号，用来与查询到的每行记录的版本号进行比较。
* 系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
* 事务版本号：事务开始时的系统版本号。

![存储概览](/img/mysql/10.png)

在 InnoDB 中，每一行都有 2 个隐藏列 DATA_TRX_ID 和 DATA_ROLL_PTR (如果没有定义主键，则还有个隐藏主键列)：

1. DATA_TRX_ID 表示最近修改该行数据的事务 ID
2. **DATA_ROLL_PTR 则表示指向该行回滚段的指针，该行上所有旧的版本，在 undo 中都通过链表的形式组织，而该值正是指向 undo 中该行的历史记录链表**

整个 MVCC 的关键就是通过 DATA_TRX_ID 和 DATA_ROLL_PTR 这两个隐藏列来实现的。

#### 事务链表
MySQL 中的事务在开始到提交这段过程中，都会被保存到一个叫 trx_sys 的事务链表中，这是一个基本的链表结构：
![存储概览](/img/mysql/11.png)

事务链表中保存的都是还未提交的事务，事务一旦被提交，则会被从事务链表中摘除。

#### ReadView
有了前面隐藏列和事务链表的基础，接下去就可以构造 MySQL 实现 MVCC 的关键 —— ReadView。

ReadView 是一个数据结构，在 SQL 开始的时候被创建。这个数据结构中包含了 3 个主要的成员：ReadView{low_trx_id, up_trx_id, trx_ids}，在并发情况下，一个事务在启动时，trx_sys 链表中存在部分还未提交的事务，那么哪些改变对当前事务是可见的，哪些又是不可见的，这个需要通过 ReadView 来进行判定，首先来看下 ReadView 中的 3 个成员各自代表的意思：

1. low_trx_id 表示该 SQL 启动时，当前事务链表中最大的事务 id 编号，也就是最近创建的除自身以外最大事务编号
2. up_trx_id 表示该SQL启动时，当前事务链表中最小的事务 id 编号，也就是当前系统中创建最早但还未提交的事务
3. trx_ids 表示所有事务链表中事务的 id 集合

上述 3 个成员组成了 ReadView 中的主要部分，简单图示如下：

![存储概览](/img/mysql/12.png)

根据上图所示，所有数据行上 DATA_TRX_ID 小于 up_trx_id 的记录，说明修改该行的事务在当前事务开启之前都已经提交完成，所以对当前事务来说，都是可见的。而对于 DATA_TRX_ID 大于 low_trx_id 的记录，说明修改该行记录的事务在当前事务之后，所以对于当前事务来说是不可见的。

最后，至于位于（up_trx_id, low_trx_id）中间的事务是否可见，这个需要根据不同的事务隔离级别来确定。对于 RC 的事务隔离级别来说，对于事务执行过程中，已经提交的事务的数据，对当前事务是可见的，也就是说上述图中，当前事务运行过程中，trx1~4 中任意一个事务提交，对当前事务来说都是可见的；而对于RR隔离级别来说，事务启动时，已经开始的事务链表中的事务的所有修改都是不可见的，所以在 RR 级别下，low_trx_id 基本保持与 up_trx_id 相同的值即可。

> 注意，ReadView 是与 SQL 绑定的，而并不是事务，所以即使在同一个事务中，每次 SQL 启动时构造的ReadView 的 up_trx_id 和 low_trx_id 也都是不一样的，至于 DATA_TRX_ID 大于 low_trx_id 本身出现也只有当多个 SQL 并发的时候，在一个 SQL 构造完 ReadView 之后，另外一个 SQL 修改了数据后又进行了提交，对于这种情况，数据其实是不可见的。

最后用一张图来解释 MySQL 中的 MVCC 实现：

![存储概览](/img/mysql/14.png)

#### 快照读与当前读

在 RR 级别中，通过 MVCC 机制，虽然让数据变得可重复读，但数据可能是历史数据，不是数据库最新的数据。这种读取历史数据的方式，即快照读 (snapshot read)，而读取数据库最新版本数据的方式，叫当前读 (current read)。

###### 快照读

当执行 select 操作时 innodb 默认会执行快照读，会记录下这次 select 后的结果，之后 select 的时候就会返回这次快照的数据，即使其他事务提交了不会影响当前 select 的数据，这就实现了可重复读了。快照的生成当在第一次执行 select 的时候，也就是说假设当 A 开启了事务，然后没有执行任何操作，这时候B insert了一条数据然后commit,这时候A执行 select，那么返回的数据中就会有 B 添加的那条数据。之后无论再有其他事务 commit 都没有关系，因为快照已经生成了，后面的 select 都是根据快照来的。使用 MVCC 读取的是快照中的数据，这样可以减少加锁所带来的开销。

```
select * from table ...;
```

###### 当前读
对于会对数据修改的操作(update、insert、delete)都是采用当前读的模式。在执行这几个操作时会读取最新的记录，即使是别的事务提交的数据也可以查询到。假设要 update一条记录，但是在另一个事务中已经 delete 掉这条数据并且 commit 了，如果 update 就会产生冲突，所以在 update 的时候需要知道最新的数据。读取的是最新的数据，需要加锁。以下第一个语句需要加 S 锁，其它都需要加 X 锁。

```
select * from table where ? lock in share mode; 
select * from table where ? for update; 
insert; 
update; 
delete;
```

##  实现
下文介绍 REPEATABLE READ（可重复读）隔离级别下 MVCC 如何工作。当开始新一个事务时，该事务的版本号肯定会大于当前所有数据行快照的创建版本号，理解这一点很关键。
#### SELECT
InnoDB 会根据以下条件检查每一行记录：
1. InnoDB 只查找版本早于当前事务版本的数据行，这样可以确保事务读取的行要么是在开始事务之前已经存在要么是事务自身插入或者修改过的，在事务开始之后才插入的行，事务不会看到
2. 行的删除版本号要么未定义，要么大于当前事务版本号，这样可以确保事务读取到的行在事务开始之前未被删除，在事务开始之前就已经过期的数据行，该事务也不会看到。只有符合上述两个条件的才会被查询出来

#### INSERT
将当前系统版本号作为数据行快照的创建版本号。

#### DELETE
将当前系统版本号作为数据行快照的删除版本号。

#### UPDATE
将当前系统版本号作为更新前的数据行快照的删除版本号，并将当前系统版本号作为更新后的数据行快照的创建版本号。可以理解为先执行 DELETE 后执行 INSERT。

保存这两个版本号，使大多数操作都不用加锁。使数据操作简单，性能很好，并且能保证只会读取到复合要求的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作和一些额外的维护工作。


> MVCC 只在 COMMITTED READ（读提交）和 REPEATABLE READ（可重复读）两种隔离级别下工作。

可以认为 MVCC 是行级锁一个变种，但是他很多情况下避免了加锁操作，开销更低。虽然不同数据库的实现机制有所不同，但大都实现了非阻塞的读操作（读不用加锁，且能避免出现不可重复读和幻读），写操作也只锁定必要的行（写必须加锁，否则不同事务并发写会导致数据不一致）。

## 参考文献
[参考](https://segmentfault.com/a/1190000012650596)
[乐观锁和 MVCC 的区别？ - fleuria的回答 - 知乎](https://www.zhihu.com/question/27876575/answer/62496641)


