---
layout: post
title: "MySQL 系列 事务"
subtitle: '《Mysql 技术内幕：InnoDB存储引擎》'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 事务会把数据库从一种一致状态转换到另一种一致状态。事务是访问并更新数据库中各种数据项的一个程序执行单元。在数据库提交事务时，可以保证要么所有修改都保存成功，要么所有修改都不保存。


## 事务四大特性（ACID）
对于 Innodb 存储引擎来说，其默认的事务隔离级别是 read repeatable，完全遵循和满足事务 ACID 特性。

#### 原子性（Atomicity）
事务原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现两种状态之一: 全部执行成功或全部执行失败

任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功。

#### 一致性（Consistency）
事务一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如：如果从 A 账户转账到 B 账户，不可能因为 A 账户扣了钱，而 B 账户没有加钱。

#### 隔离性（Isolation）
事务隔离性是指在并发环境中，并发的事务是互相隔离的，一个事务的执行不能被其它事务干扰。也就是说，不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间。

在标准 SQL 规范中，定义了 4 个事务隔离级别，不同的隔离级别对事务的处理不同。4个隔离级别分别是：读未提交（READ_UNCOMMITTED）、读已提交（READ_COMMITTED）、可重复读（REPEATABLE_READ）、顺序读（SERIALIZABLE）。 

事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务是不能互相干扰的。

#### 持久性（Durability）
事务持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器系统崩溃或服务器宕机等故障。只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。**持久性保证事务系统的高可靠性， 而不是高可用性**

## 事务隔离级别
MySQL 定义了四种隔离级别，包括一些具体规则，用于限定事务内外哪些改变是可见的，哪些改变是不可见的。低级别的隔离一般支持更高的并发处理，并且拥有更低的系统开销。

**在实现上，数据库里面会创建一个视图(ReadView)，访问的时候以视图的逻辑结果为准。在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；而“串行化”隔离级别下直接用加锁的方式来避免并行访问。**

#### read uncommitted 读未提交
此隔离级别，所有事务都可以“看到”未提交事务的变更。其隔离级别是最低的。读取未提交数据，也被称为“脏读”，脏读示例：
![脏读示例](/img/mysql/脏读示例.png)

余额应该为 1500 元才对。请看 T5 时间点，事务 A 此时查询的余额为 0，这个数据就是脏数据，这是事务 B 造成的，很明显是事务没有进行隔离造成的。

#### read committed 读已提交
大多数数据库系统的默认隔离级别（不是 MySQL 的默认隔离级别），满足了隔离的早先简单定义：一个事务开始时，只能“看见”已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别同样是“不可重复读”，这意味着用户运行同一个语句两次，看到的结果是不同的。
![不可重复读示意图](/img/mysql/不可重复读示意图.png)

事务 A 其实除了查询两次以外，其它什么事情都没做，结果钱就从1000变成0了，这就是不可重复读的问题。

#### repeatable read 可重复读
MySQL 数据库默认的隔离级别。一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。该事务隔离级别限制了不可重复读取和脏读。InnoDB 使用 Next-key Lock 锁和 MVCC 避免了不可重复读的问题。即 InnoDB 在可重复读事务隔离级别下已经完全保证事务隔离性的要求，即达到 SQL 标准的 serializable 隔离级别。

#### serializable 可串行化
在 serializable 隔离级别中， 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

serializable 的事务隔离级别主要用于 InnoDB 存储引擎的分布式事务。


## 事务实现
* 隔离性：写隔离是锁来实现，读隔离是 MVCC 实现
* 原子型、持久性、一致性：通过数据库的 redo log（重做日志，保证事务原子型和持久性）和 undo log（保证事务的一致性）进行实现

InnoDB 存储引擎通过 ```Write-Ahead Logging``` 机制实现事务的持久性，即当事务提交时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务的 commit 操作完成才算完成。重做日志包括 redo log 和 undo log， redo log保证事务的持久性，undo log 用来帮助事务回滚及 MVCC 的功能。   
* redo 和 undo的作用都可以视为一种恢复操作，redo 恢复提交事务修改的页操作，而 undo 回滚行记录到某个特定版本
* redo log 基本上都顺序写的，在数据库运行期间不需要对 redo log 文件进行读取操作。
* undo log 是需要进行随机读写的。

为了确保每次日志都写入重做日志文件，在每次将重做日志缓冲写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync操作。

## 相关SQL命令： 　　
* 在MySQL数据库中查看当前事务的隔离级别：
```
  select @@tx_isolation; 
```
* 在MySQL数据库中设置事务的隔离级别：
```
	set  [glogal | session]  transaction isolation level 隔离级别名称; 或：
  set tx_isolation=’隔离级别名称;’ 
```
