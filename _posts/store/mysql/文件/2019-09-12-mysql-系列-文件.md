---
layout: post
title: "MySQL 系列 文件"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 主要介绍《MySQL 技术内幕：InnoDB存储引擎》第五章有关文件相关知识点，

## 参数文件
指定初始化参数、数据库文件目录位置：
#### 动态参数
可以在MySQL是运行中进行更改
#### 静态参数
在整个实例生命周期中都不得进行更改。
## MySQL 表结构文件
用来存放mysql表结构及视图定义的文本文件（.frm）。
## 存储引擎文件（innodb）
存储了记录和索引等数据
#### 重做日志文件
重做日志文件对于 InnoDB 存储引擎至关重要，记录了对于 InnoDB 存储引擎的事务日志。记录的是关于每个页的更改的物理情况。在事务进行中，不断有重做日志条目被写入重做日志文件中。当实例或介质失败时，重做日志文件就能派上用场，保证数据的完整性。
重做日志文件的大小设置对于InnoDB存储引擎的性能有着非常大的影响：
* 重做日志文件设置太大，在恢复时可能需要很长的时间
* 重做日志文件设置太小，可能导致一个事务的日志需要多次切换重做日志文件。此外，会导致频繁的async checkpoint,导致性能的抖动。
重做日志有一个 capacity 变量，该变量代表了最后的检查点不能超过这个阈值，如果超过则必须将缓冲池中脏页列表中的部分脏页写回磁盘，这时会发生用户线程的阻塞。
写入重做日志文件的操作不是直接写，而是先写入一个重做日志缓冲中，然后按照一定的条件顺序地写入日志文件。

> 从重做日志缓冲往磁盘写入时，是按512个字节，是按一个扇区的大小进行写入。因为扇区是写入的最小单位，因此可以保证写入必然是成功的。因此在重做日志的写入过程中不需要有二次写。

**重做日志文件刷盘策略：**
* 级别0:代表当提交事务时，并不将事务的重做日志写入磁盘的日志文件，而是主线程中每秒会将重做日志缓冲写入磁盘的重做日志文件中，无论事务是否已经提交。
* 级别1: 执行 commit 时，将重做日志缓冲同步写入磁盘，即伴有 fsync 的调用
* 级别2: 将重做日志异步写到磁盘，即写到文件系统的缓冲中。
只有级别1能保证事务ACID中的持久性。

#### 表空间文件
MySQL数据的存储是根据表进行的，每个表都会有与之相应的文件，InnoDB 采用将存储的数据按表空间进行存放的设计.
**共享表空间**    
共享表空间： Innodb的表的数据默认保存在共享表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从Innodb的官方文档中可以看到，其表空间的最大限制为64TB，也就是说，Innodb的单表限制基本上也在64TB左右了，当然这个大小是包括这个表的所有索引等其他相关数据。    
*不管是共享表空间和独立表空间，都会存在innodb_data_file文件* 

> 共享表空间的优点:    
表空间可以分成多个文件存放到各个磁盘，所以表也就可以分成多个文件存放在磁盘上，表的大小不受磁盘大小的限制。

> 共享表空间的缺点:    
* 所有的数据和索引存放到一个文件，虽然可以把一个大文件分成多个小文件，但是多个表及索引在表空间中混合存储，当数据量非常大的时候，表做了大量删除操作后表空间中将会有大量的空隙，特别是对于统计分析，对于经常删除操作的这类应用最不适合用共享表空间。
* 共享表空间分配后不能回缩：当出现临时建索引或是创建一个临时表的操作表空间扩大后，就是删除相关的表也没办法回缩那部分空间了（可以理解为oracle的表空间10G，但是才使用10M，但是操作系统显示mysql的表空间为10G），进行数据库的冷备很慢；

**独立表空间**    
每个表都有自已独立的表空间，每个表的数据和索引都会存在自已的表空间中，可以实现单表在不同的数据库中移动。
*独立表空间只存储该表的数据、索引、插入缓存bitmap等信息，其余信息还是存入默认的表空间中*

> 独立表空间的优点:    
空间可以回收（除drop table操作处，表空不能自已回收）   
Drop table操作自动回收表空间，如果对于统计分析或是日值表，删除大量数据后可以通过:alter table TableName engine=innodb;回缩不用的空间。   
对于使innodb-plugin的Innodb使用turncate table也会使空间收缩。   
对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。   

> 独立表空间的缺点:    
单表增加过大，当单表占用空间过大时，存储空间不足，只能从操作系统层面思考解决方法。

------

# 相关命令
* 查看配置文件的位置，mysql 实例会按一定的顺序在指定的位置进行读取配置文件：    
``` mysql --help | grep my.cnf```        

* 查看数据库中所有的参数,可以通过like来过滤参数名：    
```
show variables    
show variables like 'XXX%'
```    

* 定位错误日志文件：    
```show variables like 'log_error'```     

* 修改动态参数：   
``` 
set [global | session] system_var_name = expr       
set [@@global. | @@session. @@] system_var_name =expr   
```     
global和session关键字表明该参数的修改是基于当前会话还是整个实例的生命周期。


* 查询动态参数：
```
get [global | session] system_var_name = expr     
get [@@global. | @@session. @@] system_var_name =expr
```    
global和session关键字表明该参数的修改是基于当前会话还是整个实例的生命周期。

* 开启慢查询（默认情况下，mysql并不启动慢查询日志）：
```show variables like 'long_query_time' ```


* mysqldumpslow命令     
``` mysqldumpslow -s al -n 10 david.log```
得到执行时间最长的10条sql语句。


* 查看二进制日志中的记录：
show binlog event


* 查看当前数据库的表空间管理类型：   
```show variables like "innodb_file_per_table";```

