---
layout: post
title: "MySQL 系列 表文件"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 表是关于特定实体的数据集合，也是关系型数据库模型的核心。

## 逻辑存储结构
所有数据都被逻辑地存放在一个空间中，称为表空间。表空间由段、区、页组成。InnoDB 存储引擎的逻辑存储结构如图: 
![逻辑存储结构](/img/mysql/tablespace.png)

#### 表结构
在 MySQL 8.0 版本以前，表结构是存在以```.frm```为后缀的文件里。而 MySQL 8.0 版本，则已经允许把表结构定义放在系统数据表中了。
#### 表空间
表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数```innodb_file_per_table```控制的：
* 这个参数设置为```OFF```表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起
* 这个参数设置为```ON```表示的是，每个 InnoDB 表数据存储在一个以 ```.ibd```为后缀的文件中

独立表空间只存放数据、索引和插入缓存 bitmap 页。其他的数据，如 undo log(回滚信息)、插入缓存索引页、系统事务信息、二次写缓存等还是存放在共享表空间中。
###### 共享表空间
InnoDB 的表的数据默认保存在共享表空间里面，而这个表空间可以由很多个文件组成，一个表可以跨多个文件存在，所以其大小限制不再是文件大小的限制，而是其自身的限制。从 InnoDB 的官方文档中可以看到，其表空间的最大限制为 64TB，也就是说，InnoDB 的单表限制基本上也在 64TB 左右了，当然这个大小是包括这个表的所有索引等其他相关数据。    
*不管是共享表空间和独立表空间，都会存在innodb_data_file文件* 

> 共享表空间的优点:    
表空间可以分成多个文件存放到各个磁盘，所以表也就可以分成多个文件存放在磁盘上，表的大小不受磁盘大小的限制。

> 共享表空间的缺点:    
> * 所有的数据和索引存放到一个文件，虽然可以把一个大文件分成多个小文件，但是多个表及索引在表空间中混合存储，当数据量非常大的时候，表做了大量删除操作后表空间中将会有大量的空隙，特别是对于统计分析，对于经常删除操作的这类应用最不适合用共享表空间。
> * 共享表空间分配后不能回缩：当出现临时建索引或是创建一个临时表的操作表空间扩大后，就是删除相关的表也没办法回缩那部分空间了（可以理解为oracle的表空间10G，但是才使用10M，但是操作系统显示mysql的表空间为10G），进行数据库的冷备很慢；

###### 独立表空间 
每个表都有自已独立的表空间，每个表的数据和索引都会存在自已的表空间中，可以实现单表在不同的数据库中移动。
*独立表空间只存储该表的数据、索引、插入缓存 bitmap 等信息，其余信息还是存入默认的表空间中*

> 独立表空间的优点:    
> * 空间可以回收（除drop table操作处，表空不能自已回收）   
> * Drop table 操作自动回收表空间，如果对于统计分析或是日值表，删除大量数据后可以通过:alter table TableName engine=innodb;回缩不用的空间。   
> * 对于使innodb-plugin的Innodb使用turncate table也会使空间收缩。   
> * 对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。   

> 独立表空间的缺点:    
> 单表增加过大，当单表占用空间过大时，存储空间不足，只能从操作系统层面思考解决方法。 

#### 段      
表空间由各个段组成:
* 数据段：即 B+ 树的叶子节点
* 索引段：即 B+ 树的非索引节点
* 回滚段      
   
#### 区 
由连续页组成的空间，在任何情况下每个区的大小都是 1MB。    
**在默认情况下，InnoDB 存储引擎每个数据页的大小默认是 16KB，即一个区中一共有 64 个连续的页。**
在用户启动了参数 innodb_file_per_table 后，在每个段开始时，先用 32 个页大小的碎片页来存放数据，在使用完这些页之后才是 64 个连续页的申请。    

#### 页 
InnoDB 数据是按数据页为单位来读写的。也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。在 InnoDB 中，每个数据页的大小默认是 16KB，可通过 innodb_page_size 将页的大小设置为 4K、8K、16K。 
###### 数据页结构
InnoDB 数据页由以下 7 个部分组成：
* file header 文件头
* page header 页头
* infimun 和 supernum records： infimum是比该页中任何主键值都要小的值，supernum 指比任何可能大的值还要大的值。
* user records用户记录，即行记录
* free space 空闲空间
* page directory 页目录： 存放了记录的相对位置
* file trailer 文件结尾目录
其中file header、page header、file trailer的大小是固定的，分别为38、56、8字节，这些空间用来标记该页的一些信息。
user records、free spare、page directory这些部分为实际的行记录存储空间，因此大小是动态的

#### 行 
InnoDB 存储引擎是面向列的，也就是数据是按行进行存放的。每个页允存放的行记录有硬性规定，最多允许存放 16KB/2-200 = 7992 行的记录。     

###### 行记录的格式（行记录的组织规则）    
记录是以行的形式存储的，页中保存着表中一行行的数据，数据库实例的作用之一就是读取页中存放的行记录。InnoDB 存储引擎提供了 Compact和 Redundant两种格式来存放行记录数据。       

**compact 行记录的设计目标是高效的存储数据（一个页中存储的行数据越多，其性能就越高），格式如下：**          
![存储概览](/img/mysql/compact.png)    
1. 变长字段长度列表，其按照列的顺序逆序放置：变长字段长度最大不超过2字节（MySQL数据库varcahr类型的最大长度限制为65535）   
2. NULL标识位：该标识的每一位指示了该行数据中对应字段是否为NULL值，有则用1。    
3. 记录头信息：固定占用5字节（40位）   
![存储概览](/img/mysql/header.png)    
4. 列N数据：实际存储每列的数据，NULL不占该部分任何空间，即NULL占有NULL标志位，实际存储不占任何空间。      

> 注： 
1. 每一行数据除了用户定义的例外，还有两个隐藏列，事物ID列和回滚指针列，分别为6字节和7字节的大小，若InnoDB表没有定义主键，每行还未增加一个6字节的rowid列。   
2. innodb 存储引擎在页内部是通过一种链表的结构来串联各个行记录的
3. varchar 类型的最大长度为65532   

**行溢出数据**     
InnoDB 存储引擎可以将一条记录中的某些数据存储在真正的数据页面之外。
**InnoDb存储引擎表是索引组织的，即B+树结构，这样每个页中至少应该有两条行记录。因此，如果页中只能存放下一条记录，那么InnoDB存储引擎会自动将行数据存放在溢出页中**
![存储概览](/img/mysql/cache.png)    

## 约束
关系数据库本身能保证存储数据的完整性，不需要应用程序的控制。关系型数据库通过约束机制提供了一条强大而简易的途径来保证数据库中数据的完整性。
* 实体完整性保证表中有一个主键。在InnoDB存储引擎表中，用户可以通过定义primary key或unique key约束来保证实体的完整性
* 域完整性保证数据每列的值满足特定的条件
* 参照完成性保证两张表之间的关系。用户定义外键以强制参照完整性 

## 分区
分区的过程是将一个表或索引分解为多个更小、更可管理的部分。MySQL数据库的分区是局部分区索引，一个分区中既存放了数据还存放了索引

## 相关命令
* 查看配置文件的位置，mysql 实例会按一定的顺序在指定的位置进行读取配置文件：    
``` mysql --help | grep my.cnf```        

* 查看数据库中所有的参数,可以通过like来过滤参数名：    
```
show variables    
show variables like 'XXX%'
```    

* 定位错误日志文件：    
```show variables like 'log_error'```     

* 修改动态参数：   
``` 
set [global | session] system_var_name = expr       
set [@@global. | @@session. @@] system_var_name =expr   
```     
global和session关键字表明该参数的修改是基于当前会话还是整个实例的生命周期。


* 查询动态参数：
```
get [global | session] system_var_name = expr     
get [@@global. | @@session. @@] system_var_name =expr
```    
global和session关键字表明该参数的修改是基于当前会话还是整个实例的生命周期。

* 开启慢查询（默认情况下，mysql并不启动慢查询日志）：
```show variables like 'long_query_time' ```


* mysqldumpslow命令     
``` mysqldumpslow -s al -n 10 david.log```
得到执行时间最长的10条sql语句。


* 查看二进制日志中的记录：
show binlog event


* 查看当前数据库的表空间管理类型：   
```show variables like "innodb_file_per_table";```

