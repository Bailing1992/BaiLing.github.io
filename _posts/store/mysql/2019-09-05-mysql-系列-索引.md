---
layout: post
title: "MySQL 系列 索引"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。索引的常见模型包括哈希表、有序数组和搜索树


## B+树
B+树是为磁盘或其它直接存取辅助设备设计的一种平衡查找树（满足任意节点的两个子树的高度最大差为1）。

在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点上，由各叶子结点指针进行链接。

B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。在页中的查找可以理解为二分查找。

> 插入：
   采用旋转操作使 B+ 树减少页的拆分操作
> 删除：
   使用填充因子来控制树的删除变化
     
## 索引分类
B+树 索引的本质就是 B+树 在数据库中的实现。但是 B+索引 在数据库中有一个特点是高扇出性，因此在数据库中，B+树 的高度一般在 2～4 层。

对于字符串字段，可以添加前缀索引，使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。

```
select count(distinct left(email, 4)）as L4 from SUser;
```
#### 聚集索引（又称主键索引）
InnoDB存储引擎表是索引组织表，即表中数据按照主键顺序存放，为索引的一部分。
聚集索引就是按照每张表的主键构造一颗B+树，叶子节点中存放的即为整张表的行记录数据，叶子节点即为数据页，每个数据页通过双向链表进行链接。

> 注：聚簇索引的存储并不是物理上连续的，而是逻辑上连续的
1. 页通过双向链表链接，页按照主键的顺序排序
2. 每个页中的记录也是通过双向链表进行维护，物理存储同样可以不按照主键存储。
  
> 在多数情况下，查询优化器倾向于采用聚集索引。因为聚集索引能够在B+树索引的叶子结点上直接找到数据，有利于对于主键的排序查找和范围查找。查询优化器能够快速发现某一段范围的数据页需要扫描。

#### 辅助索引（又称二级索引、非主键索引）
叶子节点除了包含键值以外，每个叶子节点中的索引行中还包含一个书签（相应行数据的聚集索引键，即主键值）。该书签用来告诉InnoDB存储引擎哪里可以找到与索引相对应的行数据。辅助索引的书签就是相应行数据的聚集索引键（页级别）。

当通过辅助索引来寻找数据时，InnoDB 存储引擎会遍历辅助索引并通过页级别的指针获取指向主键索引的主键。然后再通过主键索引来找到完整的行记录。
#### 唯一索引
对于查找，唯一索引和普通索引的区别：
* 对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。
* 对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。
  
对于更新，唯一索引和普通索引的区别：
* 唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用
* 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反**唯一性约束**。比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 **change buffer** 了。

#### 联合索引：
联合索引是指表上的多个列进行索引，符合向左匹配原则。联合索引的键值的数量不是1，而是大于等于2。键值都是排序的，通过叶子节点可以逻辑上顺序地读出所有数据。    
**要点：联合索引已经对每个键值进行了排序处理（与 order by结合使用）：**     

**实例:**
```
create table buy_log(
   user_id int unsigned not null,
   buy_date date
   primary key (user_id),
   key idx_a_b(user_id, buy_date)
)
```           
1. 每个叶子节点包含的键值个数: `select * from buy_log where user_id =2;`  // 优化器选择单个索引，因为该索引的叶子节点包含单个键值，所以理论上一个页存放的记录应该更多。
2. 能否利用多个键值的联合索引: 联合索引的每个字段都是有序的，order by 能够利用这些有序的数据，但需要满足向左匹配原则：
`select * from buy_log where user_id = 1 order by buy_date desc limit 3`   // 优化器使用了联合索引，因为第二个字段 buy_date 是有序的。

#### 覆盖索引
覆盖索引（covering index）指一个查询语句的数据只用从辅助索引中就能够取得，不必从数据表（查询聚集索引）中读取（不用回表）。也可以称之为实现了索引覆盖。
1. 覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，故其大小要远小于聚集索引，因此可以减少大量的IO操作
2. 统计查询时，选择辅助索引可以减少IO操作。

**使用前缀索引就用不上覆盖索引对查询性能的优化了。**

**示例:**   
```
create table buy_log(
    user_id int unsigned not null,
    buy_date date
    primary key (user_id),
    key idx_a_b(user_id, buy_date)

)
```      
1. `select count(*) from buy_log `
优化器查询辅助索引进行统计，原因是辅助索引比聚集索引更小，每个叶子节点包含的数据条数更多。

2. `select count(*) from buy_log where buy_date>= '2011-01-01' and buy_date < '2011-02-01'`  
统计查询，可以利用到覆盖索引中的信息，因此优化器会使用该联合索引。

###### 索引下推优化
MySQL 5.6 引入的索引下推优化（index condition pushdown)。在满足最左匹配的基础上，可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。
Index Condition Pushdown 是一种根据索引进行查询的优化方式。在支持 Index Condition Pushdown 之后，MySQL数据库会在取出索引的同时，判断是否可以进行 where 条件的过滤，也就是将 where 的部分过滤操作放在了存储引擎层。

#### Fast Index Creation 快速索引创建
对于辅助索引的创建，InnoDB存储引擎会对创建索引的表加一个S锁。在创建的过程中，不需要重建表，因此速度较之前提高很多，并且数据库的可用性也得到了提高。
由于加了S锁，在创建过程中只能对该表进行读操作。
*对于主键的创建和删除需要重建一张表。*

#### muiti-range read 多范围读
muiti-range read 优化的目的是减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问。
MySQL 将根据辅助索引获取的结果集根据主键进行排序，将随机访问化为较为顺序的数据访问，可以按照主键顺序书签查找（回表）
按照主键顺序进行访问，可以避免频繁的离散读操作导致的缓存中页被替换出缓存池，然后又不断写入缓存池的现象。
MRR还可以将某些范围查询，将查询条件进行拆分，拆分为键值对（在拆分的过程中，直接过滤一些不符合查询条件的数据），以此来进行批量的数据查询。
# 相关问题
#### 添加索引时需要考虑的因素
1. 不是在所有的查询条件中出现的列都需要添加索引。在表中数据具有高选择性时，B+树索引才有意义（高选择性，使用```show index```命令结果中的 ```cardinality``` 列，表示索引中不重复记录数量的预估值）；
2. 关注多张表之间的联接操作，关联的键需要加索引
3. 在 OLAP 应用中，通常需要对时间字段进行索引，因为大多数统计需要根据时间维度进行数据的筛选。

>  注：Cardinality 的统计放在存储引擎层进行，通过采样的方式进行

#### 自增索引有什么好处？
1. 自增主键的插入数据模式，正符合递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。
2. 主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。由于每个非主键索引的叶子节点上都包含主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约 20 个字节，而如果用整型做主键，则只要 4 个字节，如果是长整型（bigint）则是 8 个字节。
#### 优化器什么时候不使用索引
* 有时优化器没有选择扫描辅助索引，而是通过扫描聚集索引，这种情况多发生于范围查找、Join链接操作等情况下：
    * 当查询数据是整行信息而辅助索引不能覆盖时（需要回表查询），而且被查询数据量很多时（大于20%），选择聚集索引。
    * 对于不能进行索引覆盖的情况，优化器选择辅助索引的情况是，通过辅助索引查询的数据量是少量的。
* 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能，但是可以选择全索引扫描。
    * 有数据类型转换，就需要走全索引扫描。在MySQL中，字符串和数字做比较的话，是将字符串转换成数字
    * 有隐式字符编码转换，就需要走全索引扫描

#### 使用索引查询一定能提高查询的性能吗？
通常，通过索引查询数据比全表扫描要快，也必须注意到它的代价。
1. 索引需要空间来存储，也需要定期维护，每当有记录在表中增减或索引列被修改时，索引本身也会被修改。这意味着每条记录的INSERT，DELETE，UPDATE 将为此多付出 4、5 次的磁盘 I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:
2. 基于一个范围的检索，一般查询返回结果集小于表中记录数的 30%
3. 基于非唯一性索引的检索
# 相关命令：
#### EXPALIN
执行 EXPALIN 获取 MySQL 数据库的执行计划。

|  字段：   | 释义  |
|  ----                       |           ----                   |
| rows                        | 预计的返回函数                     |  
| possible_keys               |  SQL可能使用的索引                 | 
| key                         | 实际使用的索引                     | 
| type                        |  查询类型                         | 
| range                       |  范围查询                         |   
| extra:Using where           | 表示优化器需要通过索引回表查询数据；   |
| extra:Using filesort        | 需要额外的排序操作才能完成查询，通常在使用```order by```情况下会出现。MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。排序可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size。   | 
| extra:Using index           | 表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表，即优化器进行了覆盖索引操作。   |  
| extra:Using intersect(b,a)  |  表示根据两个索引得到的结果进行求交的数据运算，最后得到结果。         |
| extra:Using index condition | 在 MySQL 5.6 版本后加入的索引下推优化（Index Condition Pushdown）会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行。                    |
| extra:Using MRR | 启用主键排序后回表或对查询条件进行拆分。            |   
| extra:Using temporary | 表示的是需要使用临时表                     |   


