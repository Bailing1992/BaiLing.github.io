---
layout: post
title: "MySQL 系列 查询优化"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
update_at: "2023-10-10"
header-img: "img/post/bg/post-bg-夕阳.jpeg"
catalog: true
tags:
  - mysql
---

SQL 语句经过优化器的优化后会生成查询计划，查询计划分为若干个步骤，每一个步骤都包含一个或者多个sql算子。

> 什么是SQL算子：SQL算子可以理解为SQL语句执行过程中各个步骤的具体动作。

## 常用SQL算子分类

- scan算子

  Scan 算子是用于扫描操作的算子，作用于表和视图。Scan 算子根据扫描的执行方式可以分为 TableScan 算子和 IndexScan 算子，分别执行顺序扫描和基于索引扫描。

- filter算子

  顾名思义，Filter 算子是条件过滤算子，用于在 SQL 语句中根据一定的条件过滤表或视图中的数据。Filter 算子中至少包含一个过滤条件，且 Filter 算子中可以包含非常复杂的过滤条件。

- join算子

  join 算子是用于完成连接操作的所有算子的统称，Join 算子本身包含了连接条件。在具体的 SQL 语句中，Join 算子可以隐式表达，也可以表达为 join … on … 形式。

- Top N算子

  Top N 算子是完成限定操作的算子的统称，限定操作指的是基于结果集并在结果集上完成某种行为的操作，Top N算子的最典型的应用场景是分页。Top N 算子具体可以表达为 Top、Limit、Offset、RowNum 等关键字。

- sort算子

  sort 算子是 SQL 语句中用于执行排序操作的算子。排序操作是 SQL 语句中的常见操作，也是重要操作，而排序算子的具体实现，在不同的数据库中经常不同，同一种数据库中也会提供多种算法用于完成排序。

- 分组算子

  分组算子是完成分组操作的算子，最常用的是 Group 算子和 Having 算子，还包括 Cube 算子、Rollup 算子等。Group 算子是完成分组操作的核心算子，而 Having 算子则提供了分组筛选条件。

- 投影算子

  投影是 SELECT 语句中的必要组成部分，表达了 SELECT 语句的输出内容的结构。投影算子可以有多种形式，甚至投影列本身就是一个独立的 SQL 语句（子查询），最常见的表现形式是表或视图中的列，此外还可以表现为 Scalar 算子、Aggregation 算子或 Window 算子。

- Scalar 算子是完成标量运算的算子，都涉及到标量函数运算。

- Aggregation 算子是聚合运算算子，包括 COUNT、MAX/MIN、SUM/AVG 等，通常结合分组算子出现。

- Window 算子是窗口操作算子，以窗口函数形式出现。Window 算子是个复合结构，可以进一步细分为窗口函数算子、Over 算子、Partition 算子和Order 算子。

- Value 算子

  Value 算子是完成非投影部分的求值运算的算子，一般表现为标量函数，通常出现于其它多种算子的各种条件表达式中，比如出现在 Filter 算子或 Join 算子中完成过滤条件表达式或连接条件表达式的求值运算。

## 执行计划

一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划，这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。

### explain命令介绍

|  字段                                        | 释义                             |
|  ----                                       |              ----                |
| rows                                        | 预计的返回函数                     |
| possible_keys                               | SQL可能使用的索引                  |
| key                                         | 实际使用的索引                     |
| type                                        | 查询类型                          |
| range                                       | 范围查询                          |
| extra.Using where                           | 表示优化器需要通过索引回表查询数据；   |
| extra.Using filesort                        | 需要额外的排序操作才能完成查询，通常在使用```order by```、```group by```情况下会出现。MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。排序可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数sort_buffer_size。               |
| extra.Using index                           | 表示直接访问索引就足够获取到所需要的数据，不需要通过索引回表，即优化器进行了覆盖索引操作。   |  
| extra.Using intersect(b,a)                  | 表示根据两个索引得到的结果进行求交的数据运算，最后得到结果。         |
| extra.Using index condition                 | 在 MySQL 5.6 版本后加入的索引下推优化（Index Condition Pushdown）会先条件过滤索引，过滤完索引后找到所有符合索引条件的数据行，随后用 WHERE 子句中的其他条件去过滤这些数据行。                                                                       |
| extra.Using temporary                       | 表示的是需要使用临时表               |
| extra.Using join buffer（Block Nested Loop   | 使用 join buffer 进行 关联，尽量避免，优化的方向就是给被驱动表的关联字段加上索引         |
| extra.Using MRR | 使用 Multi-Range Read 优化(MRR)对回表查询进行优化，启用主键排序后回表或对查询条件进行拆分。       |

> MRR 能够提升性能的核心在于，查询语句在索引上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。

- Id

  查询语句中每出现一个select，mysql就会为它分配一个唯一的id。对于连接查询，由于每个select关键字后边的from子句中可以跟随多个表，每个表在查询计划中都会对应一条记录，但是这些记录的id值都是相同的。出现在前面的表表示驱动表，出现在后面的表是被驱动表。包含自查询的查询语句可能涉及多个select关键字，所以包含子查询的查询语句的执行计划中，每一个select都会对应一个唯一的id值。