---
layout: post
title: "MySQL 系列 锁"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 锁是数据库系统区别于文件系统的一个关键特性。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完成性和一致性，实现事务的隔离性要求。


## 锁
InnoDB 存储引擎会在行级别上对表数据上锁。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。

## 锁类型
InnoDB 存储引擎实现了两种标准的行级锁: 
1. 共享锁（S Lock）: 允许事务读一行数据。 如果一个事务 T1 已经获得了行 r 的共享锁，那么另外的事务 T2 可以立即获得行 r 的共享锁。因为读取并没有改变行 r 的数据，称这种情况为锁兼容。
2. 排他锁（X Lock）: 允许事务删除或更新一行数据。 若事务 T3 想获取行 r 的排它锁，则其必须等待其他事务 T1、T2 释放行 r 上的共享锁，这种情况称为锁不兼容。

> X 锁与任何锁都不兼容，S 锁仅与 S 锁兼容

#### 锁粒度
Innodb 支持多粒度锁定， 即允许事务在行级上锁和表级上锁同时存在。

#### 意向锁
如果第二个事务试图在表级别上获取共享或排它锁，则受到第一个事务已获取的表级别意向锁的阻塞。第二个事务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁

其支持两种意向锁，意向锁之间是互相兼容的: 
* 意向共享锁（IS）: 事务有意向对表中的某些行加共享锁（S锁）
* 意向排它锁（IX）: 事务有意向对表中的某些行加排他锁（X锁）

|     \     | 意向共享锁 | 意向排它锁 |
|  -----    |    ----  |  ----  |
| 意向共享锁  |   兼容   |   兼容  |
| 意向共享锁 |    兼容   |   兼容  |

|     \     | 意向共享锁 | 意向排它锁 |
|  -----    |    ----  |  ----  |
| 表级别共享锁  |   兼容   |   互斥  |
| 表级别排他锁 |    互斥   |   互斥  |



**InnoDB 存储引擎支持意向锁设计比较简单，其意向锁即为表级别的锁。** 

**由于 InnoDB 存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求。**

**意向锁不会与行级的共享/排他锁互斥**

> 意向锁是由存储引擎维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在表对应的意向锁。
## 锁问题
通过锁机制可以实现事务的隔离级别的要求，使得事务可以并发地工作。

#### 脏读
脏数据 是指还未提交的数据。如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，则显然违反了数据库的隔离型。脏读发生的条件是需要事务的隔离级别为 Read UnCommited。

#### 不可重复读（MySQL 文档中将不可重复读定义为幻读）
不可重复读是指在一个事务内多次读取同一数据集合读到的数据是不一样的（另一个事务做了一些 DML 操作）。其违反了数据库事务一致性的要求。

在 InnodDB 存储引擎中，通过使用 Next Key Lock 算法 和 MVCC 来避免不可重读问题。在 Next Key Lock 算法下，对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住那些索引覆盖的范围（gap），因此在这个范围内插入都是不被允许的。
```  
  select * from table where col = XXX in share mode;      
    if not found any row:     
       insert into table values(...);      
```

用户可以通过 InnoDB 存储引擎的 Next Key Lock 机制在应用层面实现唯一性检查。 如果用户**通过索引**查询一个值，并对该行加上一个 SLock， 那么即使查询的值不存在，其锁定的也是一个范围，因此若没有返回任何行，那么新插入的值一定是唯一的。
#### 丢失更新
一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。例如：
1. 事务 T1 将行记录 r 更新为 v1， 但是事务 T1 并未提交
2. 与此同时，事务 T2 将行记录 r 更新为 v2， 但是事务 T2 未提交
3. 事务 T1 提交
4. 事务 T2 提交

**在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题。** 这是因为即使在 Read Uncommitted 的事务隔离级别，对于行的 DML 操作，需要对行或其他粒度级别的对象加锁。因此在步骤 2 中，事务 T2 并不能对行记录 r 进行更新操作，其会被阻塞，直到事务 T1 提交。

#### 阻塞
因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它锁占用的资源，这就是阻塞。
**在默认情况下，InnoDB 存储引擎不会回滚超时引发的错误异常，需要用户判断是否需要 COMMIT 或 ROLLBACK。**

#### 死锁
死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。   

###### 解决死锁问题的方法
* 超时：当两个事务相互等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。
* 采用 `wait-for graph` 等待图的方式进行死锁检测：更为主动的进行死锁检查。在每个事务请求锁并发生等待时都会判断是否存在回路，如存在则有死锁。通常 InnoDB 存储引擎选择回滚 undo 量最小的事务。

**InnoBD 不会回滚大部分的错误异常，但死锁除外**

#### 锁升级
将当前锁的粒度降低

> InnoDB 不存在锁升级的问题。**因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用了位图的方式。** 因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。

## 命令
```
show engine innodb status // 查看当前锁请求的信息
```

```
select * from information_schema.INNODB_TRX\G    // 查询当前运行的InnoDB事务
```
![存储概览](/img/mysql/rax.png)

```
select * from information_schema.INNODB_LOCKS\G     // 查看锁信息
```
![存储概览](/img/mysql/lock_rac.png)

```
select * from information_schema.INNODB_LOCK_WAITS\G     // 查看当前事务的等待
```
![存储概览](/img/mysql/lock_wait.png)

```
show processlist; or show full processlist;   //  参看当前运行的事务
```


## 参考文献
[介绍 Latch 锁](https://www.cnblogs.com/geaozhang/p/7287108.html)
[介绍 MySql InnoDB 中的三种行锁](https://juejin.cn/post/6844903666420285454)
[介绍 MySql InnoDB 中意向锁的作用](https://juejin.cn/post/6844903666332368909)