---
layout: post
title: "MySQL 系列 锁"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/background/锁.jpg"
catalog: true
tags:
  - mysql
---

> 锁是数据库系统区别于文件系统的一个关键特性。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完成性和一致性，实现事务的隔离性要求。

> 根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。一般lock的对象仅在事务commit或rollback后释放。此外，lock有死锁机制。
## 全局锁（不重要）
全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 ```Flush tables with read lock (FTWRL)```。当需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

全局锁的典型使用场景是做全库逻辑备份。也就是把整库每个表都```select```出来存成文本。为了保证数据的一致性，需要存储一个不能变更的视图。如果有的表使用了不支持事务的引擎，那么备份就只能通过```FTWRL```方法。这往往是 DBA 要求业务开发人员使用 InnoDB 替代 MyISAM 的原因之一。


> 在 InnoDB 中，官方自带的逻辑备份工具是 ```mysqldump```。当```mysqldump```使用参数```–single-transaction```的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。

## 表锁
MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。
表锁的语法是 ```lock tables ... read/write```。可以用```unlock tables```主动释放锁，也可以在客户端断开的时候自动释放。需要注意，```lock tables```语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。举个例子, 如果在某个线程A中执行 ```lock tables t1 read, t2 write;```这个语句，则其他线程写t1、读写t2的语句都会被阻塞。同时，线程A在执行```unlock tables```之前，也只能执行读t1、读写t2的操作。连写t1都不允许，自然也不能访问其他表。

在还没有出现更细粒度的锁的时候，表锁是最常用的处理并发的方式。而对于 InnoDB 这种支持行锁的引擎，一般不使用 lock tables 命令来控制并发，毕竟锁住整个表的影响面还是太大。

在 MySQL 5.5 版本中引入了 MDL，当对一个表做**增删改查**操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
* 读锁之间不互斥，因此可以有多个线程同时对一张表增删改查。
* 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

> MDL 会直到事务提交才释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。

## 行锁
MySQL 行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

> 根据两阶段提交协议，在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。所以如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

## InnoDB 锁
InnoDB 支持多粒度锁定，即允许事务在行级上锁和表级上锁同时存在。
InnoDB 存储引擎会在行级别上对表数据上锁。行级锁没有相关额外的开销，并可以同时得到并发性和一致性。

#### 行锁类型
行锁是对索引记录的锁定，InnoDB 存储引擎实现了两种标准的行级锁: 
1. 共享锁（S Lock）: 允许事务读一行数据。 如果一个事务 T1 已经获得了行 r 的共享锁，那么另外的事务 T2 可以立即获得行 r 的共享锁。因为读取并没有改变行 r 的数据，称这种情况为锁兼容。
2. 排他锁（X Lock）: 允许事务删除或更新一行数据。 若事务 T3 想获取行 r 的排它锁，则其必须等待其他事务 T1、T2 释放行 r 上的共享锁，这种情况称为锁不兼容。

> X 锁与任何锁都不兼容，S 锁仅与 S 锁兼容

#### 间隙锁
gap lock: 间隙锁作用在索引记录之间的间隔，又或者作用在第一个索引之前，最后一个索引之后的间隙。不包括索引本身。

**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。间隙锁之间都不存在冲突关系。**

![间隙锁之间不互锁](/img/mysql/间隙锁之间不互锁.png){:height="70%" width="70%"}
这里 session B 并不会被堵住。因为表 t 里并没有 c=7 这个记录，因此 session A 加的是间隙锁(5,10)。而 session B 也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但它们之间是不冲突的。

可能会造成死锁

#### next-key lock
间隙锁和行锁组合合称 next-key lock，每个 next-key lock 是前开后闭区间。next-key lock实际上是由间隙锁加行锁实现的。

## 加锁规则
原则1：加锁的基本单位是 ```next-key lock```。```next-key lock```是前开后闭区间。
原则2：查找过程中访问到的对象都会加锁。

优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。
优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。

一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
## 意向锁
如果第二个事务试图在表级别上获取共享或排它锁，则受到第一个事务已获取的**表级别意向锁**的阻塞。第二个事务在锁定该表前不必检查各个页或行锁，而只需检查表上的意向锁，其支持两种意向锁，意向锁之间是互相兼容的: 
* 意向共享锁（IS）: 事务有意向对表中的某些行加共享锁（S锁）
* 意向排它锁（IX）: 事务有意向对表中的某些行加排他锁（X锁）


|     \     | 意向共享锁 | 意向排它锁 |
|  -----    |    ----  |  ----  |
| 意向共享锁  |   兼容   |   兼容  |
| 意向共享锁 |    兼容   |   兼容  |


|     \     | 意向共享锁 | 意向排它锁 |
|  -----    |    ----  |  ----  |
| 表级别共享锁  |   兼容   |   互斥  |
| 表级别排他锁 |    互斥   |   互斥  |

**InnoDB 存储引擎支持意向锁设计比较简单，其意向锁即为表级别的锁。** 

**由于 InnoDB 存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求。因为全表扫描需要锁表**

**意向锁不会与行级的共享/排他锁互斥**

> 意向锁是由存储引擎维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在表对应的意向锁。

## 阻塞
因为不同锁之间的兼容性关系，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它锁占用的资源，这就是阻塞。
**在默认情况下，InnoDB 存储引擎不会回滚超时引发的错误异常，需要用户判断是否需要 COMMIT 或 ROLLBACK。**

## 死锁
死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。   
#### 解决死锁问题的方法
* 超时：当两个事务相互等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。
* 采用 `wait-for graph` 等待图的方式进行死锁检测：更为主动的进行死锁检查。在每个事务请求锁并发生等待时都会判断是否存在回路，如存在则有死锁。通常 InnoDB 存储引擎选择回滚 undo 量最小的事务。

**InnoBD 不会回滚大部分的错误异常，但死锁除外**

默认情况下采用第二种策略，即：主动死锁检测，而且```innodb_deadlock_detect```的默认值本身就是 ```on```。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。
## 锁升级
将当前锁的粒度降低

> InnoDB 不存在锁升级的问题。**因为其不是根据每个记录来产生行锁的，相反，其根据每个事务访问的每个页对锁进行管理的，采用了位图的方式。** 因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。

## 命令
```
show engine innodb status                        // 查看当前锁请求的信息
```
```
select * from information_schema.INNODB_TRX\G    // 查询当前运行的InnoDB事务
```
![存储概览](/img/mysql/rax.png)

```
select * from information_schema.INNODB_LOCKS\G  // 查看锁信息
```
![存储概览](/img/mysql/lock_rac.png)

```
select * from information_schema.INNODB_LOCK_WAITS\G // 查看当前事务的等待
```
![存储概览](/img/mysql/lock_wait.png)

```
show processlist; or show full processlist;         //  参看当前运行的事务
```
## 参考文献
[介绍 Latch 锁](https://www.cnblogs.com/geaozhang/p/7287108.html)
[介绍 MySql InnoDB 中的三种行锁](https://juejin.cn/post/6844903666420285454)
[介绍 MySql InnoDB 中意向锁的作用](https://juejin.cn/post/6844903666332368909)
[抱歉，没早点把这么全面的InnoDB锁机制发给你](https://dbaplus.cn/news-11-2518-1.html)