---
layout: post
title: "JVM 系列 垃圾收集器"
subtitle: '开启JVM探索新篇章'
author: "lichao"
header-img: "img/post-bg-digital-native.jpg"
catalog: true
tags:
  - jvm
---
> 垃圾收集器的不断更新，只为消除或减少工作线程因内存回收而导致的停顿。

基于 JDK 1.7Update 14 之后的hotspot虚拟机包含的所有垃圾回收器：
![存储概览](/img/jvm/18.png)
## Serial ( Client模式 )
>  关键词：新生代，client模式，单线程

![存储概览](/img/jvm/19.png)
Serial 收集器是最基本、历史最久的收集器，曾是新生代收集的唯一选择。它是单线程的，只会使用一个CPU或一条收集线程去完成垃圾收集工作，并且它在收集的时候，必须暂停其它所有的工作线程，直到它结束，即“Stop the World”。尽管如此，它仍然是虚拟机运行在 client 模式下的默认新生代收集器：简单而高效（与其他收集器的单个线程相比，因为没有线程切换的开销等）。
## ParNew

>  关键词：新生代，server模式

![存储概览](/img/jvm/20.png)
ParNew 收集器 是 Serial 收集器的多线程版本，除了使用了多线程之外，其他的行为（收集算法、stop the world、对象分配规则、回收策略等）同Serial收集器一样。 是许多运行在 Server 模式下的 JVM 中首选的新生代收集器，其中一个很重还要的原因就是除了Serial之外，只有它能和老年代的CMS收集器配合工作。



## CMS
>  关键词：老年代，server 模式

![存储概览](/img/jvm/21.png)
> 基于 标记-清除 算法
CMS(Concurrent Mark Sweep 并发标记收集器) 收集器是一种以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验好。基于“标记清除”算法，并发收集、低停顿，运作过程复杂，分 4 步：
1. 初始标记：仅仅标记GC Roots能直接关联到的对象，速度快，但是需要“Stop The World”
2. 并发标记：就是进行追踪引用链的过程，可以和用户线程并发执行。
3. 重新标记：修正并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录，比初始标记时间长但远比并发标记时间短，需要“Stop The World”
4. 并发清除：清除标记为可以回收对象，可以和用户线程并发执行
由于整个过程耗时最长的并发标记和并发清除都可以和用户线程一起工作，所以总体上来看，CMS 收集器的内存回收过程和用户线程是并发执行的。


> 新生代的规模一般都比老年代要小许多，新生代的回收也比老年代要频繁很多。收集器中的新生代与老年代之间的对象引用是使用Remembered Set来避免全堆扫描的

#### 缺点
1. CMS 收集器对CPU资源非常敏感：CMS默认启动的收集线程数不少于25%的CPU资源，并且随着CPU数量的增加而下降
2. CMS 收集器无法处理浮动垃圾。在垃圾回收时，需要预留有足够的内存空间给用户线程使用。在 JDK 1.5 的默认配置下，CMS收集器在老年代使用了68%的空间后就被激活。在JDK 1.6 中，CMS收集器的启动阈值已经提升到了92%
3. CMS 是一款基于“标记-清除”算法实现的收集器，会有大量空间碎片产生。

> 空间碎片过多时，将会给大对象分配带来很大麻烦。CMS会择机进行内存碎片的合并整理。



## G1
> 关键词：整个堆，服务端，标记-整理算法 及 标记-复制算法，化整为零的思想

G1（Garbage-First）是JDK7-u4才正式推出商用的收集器。G1是面向服务端应用的垃圾收集器。它的使命是未来可以替换掉CMS收集器。

G1 将整个 Java堆 划分为多个大小相等的独立区域 region，虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分region（不需要连续）的集合。

执行步骤：

1. 初始标记：仅仅标记 GC Roots 能直接关联到的对象，速度快，但是需要“Stop The World”
2. 并发标记：从 GC Root 开始对堆中对象进行可达性分析，就是进行追踪引用链的过程，可以和用户线程并发执行
3. 最终标记：修正在并发标记阶段因用户线程继续运行而导致标记发生变化的那部分对象的标记记录。虚拟机将这段时间对象变化记录在线程Remembered Set Logs中，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered 中。这阶段需要停顿线程，但是可并行执行。
4. 筛选回收：首先对各个region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。这阶段可与用户线程一起并发执行，但是停止用户线程将大幅提高收集效率。



G1 特点：
1. 并行与并发：能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短停顿的时间；
2. 分代收集：G1 可以 不需要 其他收集器的配合就能独立管理整个 Java 堆，采用不同的方式处理新生对象、已经存活一段时间的对象和熬过多次 GC 的旧对象以获得更好的收集效果。
3. 空间整合：从整体看基于标记整理算法，从局部看基于复制算法（两个Region之间），这两种算法都意味着 G1 运行期间不会产生内存空间碎片，收集后能提供规整的内存空间。不会因为大对象找不到足够的连续空间而提前触发GC，这点优于CMS收集器。
4. 可预测的停顿：追求低停顿，还能建立可以预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不超N毫秒，这点优于CMS收集器。

> 建立可预测的时间模型：G1 跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。这种使用region划分内存空间以及优先级的区域回收方式，保证了 G1 收集器在有限的时间内尽可能高的收集效率。

> Region 不可能是孤立的，而可以与整个Java堆任意的对象发生引用关系。Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用，虚拟机都是使用Remembered Set来避免全堆扫描的。G1 中每个 region 都有一个与之对应的 Remembered Set（被引用对象所属的region 的 Remembered Set 之中会记录相关的引用信息）。当进行内存回收时，在GC根结点的枚举范围中加入 Remembered Set 即可保证不对全堆扫描也不会有遗漏。
