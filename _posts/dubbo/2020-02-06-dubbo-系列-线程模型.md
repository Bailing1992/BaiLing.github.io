---
layout: post
title: "Dubbo 系列 线程模型"
author: "lichao"
header-img: "img/netty/host.png"
catalog: true
tags:
  - dubbo
---

Dubbo 默认底层网络通讯使用的是 Netty 框架，服务提供方 NettyServer 使用两级线程池，其中 EventLoopGroup(boss) 主要用来接受客户端的链接请求，并把接受的请求分发给 EventLoopGroup(worker) 来处理，boss和worker线程组我们称之为IO线程。如果服务提供方的逻辑能迅速完成，并且不会发起新的IO请求，那么直接在IO线程上处理会更快，因为这减少了线程池调度。但如果处理逻辑很慢，或者需要发起新的IO请求，比如需要查询数据库，则IO线程必须派发请求到新的线程池进行处理，否则IO线程会阻塞，将导致不能接收其它请求。

> 如果用 IO 线程处理事件，又在事件处理过程中发起新的 IO 请求，比如在连接事件中发起登录请求，会报“可能引发死锁”异常，但不会真死锁。

IO线程和业务线程的区别：
* IO线程：配置在 netty 连接点的用于处理网络数据的线程，主要处理编解码等直接与网络数据打交道的事件。
* 业务线程：用于处理具体业务逻辑的线程，可以理解为自己在 provider 上写的代码所执行的线程环境。

Dubbo 默认采用的是长链接的方式，即默认情况下一个consumer和一个provider之间只会建立一条链接，这种情况下IO线程的工作就是编码和解码数据，监听具体的数据请求，直接通过Channel发布数据等等；业务线程就是处理IO线程处理之后的数据，业务线程并不知道任何跟网络相关的内容，只是纯粹的处理业务逻辑，在业务处理逻辑的时候往往存在复杂的逻辑，所以业务线程池的配置往往都要比IO线程池的配置大很多。


## Dubbo的事件派发策略和线程池
需要通过不同的派发策略和不同的线程池配置的组合来应对不同的场景:
```
<dubbo:protocol name="dubbo" dispatcher="all" threadpool="fixed" threads="100" />
```

## 参数
#### iothreads
IO线程池（worker）的线程数量，默认情况下为 CPU个数+1，因为这个线程的工作内容比较简单，所以一般情况下我们不会去配置这个值，除非IO线程的响应速度明显拖慢了整个工程的响应，IO 线程的默认类型是 CacheThreadPool，一分钟的线程死亡时间。

#### threadpool
业务线程池的类型，默认采用 fixed 线程池，即线程数量一定的线程池，这种线程池的好处是不会频繁创建线程，适合CPU密集的应用。因为这个数据只关系到服务的并发情况，所以在需要的时候可以适当调整该数量来增加工程的并发。

* fixed 固定大小线程池，启动时建立线程，不关闭，一直持有。(缺省)
* cached 缓存线程池，空闲一分钟自动删除，需要时重建。
* limited 可伸缩线程池，但池中的线程数只会增长不会收缩。只增长不收缩的目的是为了避免收缩时突然来了大流量引起的性能问题。
* eager 优先创建Worker线程池。在任务数量大于corePoolSize但是小于maximumPoolSize时，优先创建Worker来处理任务。当任务数量大于maximumPoolSize时，将任务放入阻塞队列中。阻塞队列充满时抛出RejectedExecutionException。(相比于cached:cached在任务数量超过maximumPoolSize时直接抛出异常而不是将任务放入阻塞队列)

#### threads
业务线程池的核心线程数，默认情况下为200。如果空间有条件的话可以适当地提升该数量，例如提升至400或者500都是可以的。

#### queues
在初始化业务线程池时是否需要排队队列，如果不设置的话，业务线程池的排队队列是SynchronousQueue，即不允许业务事件排队，如果线程池没有空闲线程之后会直接返回异常信息。但是如果配置queues之后则会使用LinkedBlockingQueue作为排队队列，queues则代表队列的初始队列。因为queues的配置直接关系到排队，所以在一般情况下建议不要配置，因为线程池满的情况下一般期望是直接失败，然后调用其他的机器，而不是再次队列继续等待，继续等待不仅可能会拉低响应时间，而且很有可能会超时。

#### acceptes
我们知道threadpool，threads和queues都是控制业务线程池的字段，而acceptes就是控制IO线程池的字段。这个字段标示着服务端可接受的最大长连接数，默认情况下为不限制，但是有时候为来保护服务器防止连接数过多导致请求失败率过高，则可以考虑设置该字段为一个定值。
#### connections
既然服务端可以设置最大接收的连接数，那么客户端也可以设置与服务端建立的连接数。connections可以配置在reference上表示要同对应的服务器建立的长链接数量，默认为只建立一条链接，如果配置connections的话则会建立N条长链接以提供消费者的吞吐量。但是有一点需要注意是如果conenctions的数量配置大于服务端的accepts的话，超出的部分会直接报错，表示不支持更多的链接，该值不宜配置过多，因为如果多个消费者都配置来该值的话很容易到值服务端的accepts超过预期数量而报错。

#### dispatcher
这个字段代表的是IO线程池和业务线程池的边界，具体有这么几种类型：
* all：所有消息都派发到线程池，包括请求，响应，连接事件，断开事件，心跳等。对应的是AllChannelHandler（具体这个Handler的处理位置以及他的作用，见前几篇博客，这里不再强调）
* direct：所有消息都不派发到线程池，全部在IO线程上直接执行。（这种做法在绝大多数情况下都不合理，因为毕竟业务逻辑相关对IO事件都是复杂的）。具体的实现方式就是在装饰者的层级上直接下调，不再包装线程池。
* message：只有请求响应消息派发到线程池，其它连接断开事件，心跳等消息，直接在IO线程上执行。
* execution 只有请求消息派发到线程池，不含响应，响应和其它连接断开事件，心跳等消息，直接在 IO 线程上执行。
* connection 在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池。