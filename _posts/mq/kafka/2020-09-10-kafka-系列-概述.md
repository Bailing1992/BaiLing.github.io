---
layout: post
title: "Kafka 系列 概述"
subtitle: '深入理解Kafka'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - Kafka
---

> Kafka 是一个多分区、多副本且基于Zookeeper协调的分布式消息系统

> Kafka 是一个分布式流式处理平台，它以高吞吐、可持久化、可水平扩展、支持流数据处理等多种特性而被广泛使用。
* 消息系统
* 存储系统
* 流式处理平台： 提供完整的流式处理类库

## 系统架构
![系统架构](/img/mq/1.png)     
* Zookeeper 负责集群元数据的管理、控制器的选举等操作。
* Broker（服务代理节点），可视为一个独立的 Kafka 服务节点或 Kafka服务实例。
* 分区
* 多副本机制，leader副本负责处理读写请求，follower副本只负责与leader副本的消息同步
* 消费者：消费端会记录消费位点 offset

#### 生产者

![生产者架构](/img/mq/2.png)     

整个生产者客户端由两个线程协调运行，这两个线程分别是主线程和 Sender线程。在主线程中由 KafkaProducer 创建消息，然后通过可能的拦截器、序列化器和分区器的作用之后缓存到消息收集器中。Sender负责从消息累计器中获取消息并批量发送到 Kafka 中。

> 在消息收集器中，为每个分区都维护了一个双端队列，

> 发送消息主要有三种模式：
* 发后即忘
* 同步
* 异步

###### 默认分区器
在默认分区器 DefaultPartitioner 的实现中，逻辑是如果 key 不为 null，那么默认的分区器会对 key 进行哈希（采用MurmurHash2 算法），最终根据得到的哈希值来计算分区号，拥有相同 key 的消息会被写入同一个分区。如果 key 为 null， 那么消息将会以轮询的方式发往主题内的各个可用分区。

在不改变分区数量的情况下， key 与分区之间的映射可以保持不变。不过，一旦主题中增加了分区，那么就难以保证 key 与分区之间的映射关系了。

> 如果 key 不为空，那么计算得到的分区号会是所有分区中的任意一个。如果key为null，那么计算得到的分区号仅为可用分区中的任意一个。

###### 生产者拦截器
* 发送消息前： 在将消息序列化和计算分区之前
* 发送回调逻辑前：在消息被应答之前或消息发送失败时。这个方法运行在I/O线程，需代码逻辑简单。

> 在拦截链中，如果某个拦截器执行失败，那么下一个拦截器会接着从上一个执行成功的拦截器继续执行。

#### 消费者
Kafka 中的消费基于拉模式的。

##### 位移提交
Kafka 默认的提交方式是定期提交，这个定期的周期默认为5秒。

> 在默认情况下，

##### 指定位移消费
当消费者查找不到所记录的消费位移时，默认从分区末尾开始消费消息。

##### 再平衡

再平衡发生期间，消费组内的消费者是无法读取消息的（消费组不可用）。

可能造成消息重复消费。

## 问题
1. 分区和broker之间有什么关系

没有关系

2. follower 副本和 leader 副本间的同步方式

消息会先发送给 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。

leader 副本负责维护和跟踪 ISR 集合中所有 follower 副本的滞后状态。

3. 在异步复制方式下，如何避免主从不一致的影响？

同步复制要求所有能工作的follower副本都复制完，这条消息才会被确认为已成功提交。

4. kafka为什么高效？如何支持 Producer 端将多个小消息合并？

