---
layout: post
title: "Dubbo 系列 概述"
author: "lichao"
header-img: "img/netty/host.png"
catalog: true
tags:
  - dubbo
---

> 研究开源框架、特别是优秀的开源框架的实现原理，可以开拓我们的技术视野，提高我们的架构能力，减少由于使用不当导致的线上故障的发生.

## 服务演化
![dubbo](/img/dubbo/dubbo5.jpg)

#### 分布式服务架构
当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。

#### 流动计算架构
当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键 
## 微服务
服务之间通信方式：
* RPC框架
* Http


## RPC框架
* Dubbo


## Dubbo
Dubbo是一个分布式服务框架，致力于提供高性能透明化RPC远程调用方案，提供SOA服务治理解决方案

## 服务治理框架
![dubbo](/img/dubbo/dubbo6.jpg)

在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。

当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。

当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清关系。

接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？ 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量
## 架构
![dubbo](/img/dubbo/dubbo7.png)
调用关系说明:
1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

Dubbo 架构具有以下几个特点，分别是连通性、健壮性、伸缩性、以及向未来架构的升级性。


#### 连通性
* 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互，注册中心不转发请求，压力较小
* 监控中心负责统计各服务调用次数，调用时间等，统计先在内存汇总后每分钟一次发送到监控中心服务器，并以报表展示
* 服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间不包含网络开销
* 服务消费者向注册中心获取服务提供者地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间包含网络开销
* 注册中心，服务提供者，服务消费者三者之间均为长连接，监控中心除外
* 注册中心通过长连接感知服务提供者的存在，服务提供者宕机，注册中心将立即推送事件通知消费者
* 注册中心和监控中心全部宕机，不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表
* 注册中心和监控中心都是可选的，服务消费者可以直连服务提供者

#### 健壮性
* 监控中心宕掉不影响使用，只是丢失部分采样数据
* 数据库宕掉后，注册中心仍能通过缓存提供服务列表查询，但不能注册新服务
* 注册中心对等集群，任意一台宕掉后，将自动切换到另一台
* 注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯
* 服务提供者无状态，任意一台宕掉后，不影响使用
* 服务提供者全部宕掉后，服务消费者应用将无法使用，并无限次重连等待服务提供者恢复

#### 伸缩性
* 注册中心为对等集群，可动态增加机器部署实例，所有客户端将自动发现新的注册中心
* 服务提供者无状态，可动态增加机器部署实例，注册中心将推送新的服务提供者信息给消费者

#### 升级性
当服务集群规模进一步扩大，带动IT治理结构进一步升级，需要实现动态部署，进行流动计算，现有分布式服务架构不会带来阻力。下图是未来可能的一种架构：
![dubbo](/img/dubbo/dubbo8.jpg)


## 关注的点

#### 分层架构
首先我们可以学习和深刻体会到分层架构带来的好处，Dubbo框架在整体是分为了业务层(Business)、RPC层、远程调用(Remoting)层；
1. 业务层提供API让使用者方便的发布与引用服务；
2. RPC层则是对服务注册与发现、服务代理、路由、负载均衡等功能的封装，该层又有可以被划分为好多层；
3. 远程调用层则是对网络传输与请求数据序列/反序列化等的抽象；
    > 使用分层架构可以保证下层的改变对上层不可见，并且可以实现关注点分离，比如使用者使用Dubbo时候只关心如何使用业务层的API来发布与引用服务，而不需要关心RPC层的实现，当新版Dubbo升级了RPC层的逻辑时候，使用方只需要升级Dubbo的版本就可以了，这是因为RPC层的修改对业务层使用者来着是透明的。

#### 可扩展性 
Dubbo 是一个扩展性极强的框架，其RPC层中的所有组件都是基于SPI扩展接口实现的，每个组件都是可以被替换的；Dubbo 增强了 JDK 中提供的标准 SPI 功能，并且增加了对扩展接口的IoC （一个扩展接口可以直接 setter 注入其它扩展接口）和 AOP 的支持（可以使用Wrapper类对扩展接口进行功能增强）；并且增强SPI不会一次性实例化扩展点的所有实现类，这避免了当扩展点实现类初始化很耗时，但当前还没用上它的功能时仍进行加载实例化，浪费资源的情况；增强的 SPI 是在具体用某一个实现类的时候才对具体实现类进行实例化。

#### 容错性
作为高可用分布式RPC框架，其自身必须具有容错能力，以便提高系统的可用性: Dubbo框架则提供了分布式系统中常见的集群容错策略，并且提供了扩展接口，让使用方方便的定制自己的集群容错策略，通过研究Dubbo框架提供的集群容错策略，可以让我们对分布式系统中的容错技术有深入的理解。


#### 负载均衡
Dubbo 框架则提供了分布式系统中常见的负载均衡策略，并且提供了扩展接口，让使用方方便的定制自己的负载均衡策略；另外路由规则提供了服务治理的一种策略，在Dubbo中我们可以通过管理控制台来配置路由规则，让消费者只可访问那些服务提供者；通过研究Dubbo框架提供的负载均衡与路由策略，可以让我们对分布式系统中的负载均衡技术与路由规则有深入的理解。

#### 服务注册
在分布式系统中当我们要消费某个服务时候，如何找到其地址是一个要解决的问题，在分布式RPC中一个通用解决方案是引入服务注册中心，当服务提供者启动时候会自动把自己的服务注册到服务注册中心，当消费者启动时候会去服务注册中心订阅自己感兴趣的服务的地址列表；在Dubbo框架中则提供了扩展接口来方便的让我们使用zookeeper、redis等作为服务注册中心，通过研究Dubbo原理，我们可以深刻理解服务提供方到底是如何把服务注册到服务注册中心的，以及服务消费端如何动态的感知服务提供方地址列表变化的。

#### 代理
所有RPC框架都要解决的一个问题是，如何让使用者无感知的发起远程过程调用，也就是让使用者在发起远程调用时候，有和本地调用一样的体验；Dubbo框架和其他RPC框架一样采用代理来实现该能力，在Dubbo框架中扩展接口Proxy就是专门来做代理使用的，并且其提供了扩展接口的JDK动态代理与Cglib的实现；研究Dubbo的原理，我们可以学习到消费端如何对服务接口进行的代理以实现透明调用，服务提供端如何使用代理与JavaAssist技术减少反射调用开销的。

#### 网络传输层
在Dubbo的分层架构中 Transport 网络传输层把抽象 mina 和 netty 为统一接口，并且默认情况下其使用Netty作为底层网络通信，通过研究Dubbo，我们可以学习到Dubbo的网络协议帧是如何设计的；服务消费端如何启动Netty客户端的，如何把rpc请求封装为协议帧并序列化，然后通过Netty客户端发起网络请求的；服务提供端又是如何启动Netty服务器进行服务监听的，如何处理经典的半包、粘包问题的，如何把接受到的二进制包转换为Dubbo协议帧，并反序列化为POJO对象的；另外使用Netty时，在ChannelHandler中做阻塞的事情，以免阻塞了IO线程，使其他请求得不到及时处理。

#### 异步调用
对于网络请求来说，同步调用比较直截了当，但是同步调用意味着当前发起请求的调用线程在远端机器返回结果前必须阻塞等待，这明显很浪费资源。好的做法应该是发起请求的调用线程发起请求后，注册一个回调函数，然后马上返回去做其他事情，当远端把结果返回后再使用IO线程执行回调函数，也就是发起方实现了异步调用，调用线程不会被阻塞。Dubbo则基于Netty的异步非阻塞能力与JDK8中的CompletableFuture轻松的实现RPC请求的异步调用，提高了资源利用率；通过研究Dubbo的实现原理，我们可以对异步编程带来的好处以及实现原理有深刻的体会。
