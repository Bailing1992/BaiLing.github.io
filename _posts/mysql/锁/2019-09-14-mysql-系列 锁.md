---
layout: post
title: "MySQL 系列 锁"
subtitle: 'MySQL 技术内幕：InnoDB存储引擎'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 锁是数据库系统区别于文件系统的一个关键特性

## 锁
数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完成性和一致性。InnoDB 存储引擎会在行级别上对表数据上锁。行级锁没有相关额外的开销，并可以同时得到并发行和一致性。

> 区分 Lock 和 Latch
![存储概览](/img/mysql/lock.png)
1. latch 闩锁（轻量级的锁）：其要求锁定的时间必须非常短。 若持续的时间长，则应用的性能会非常差。用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。
2. lock ：它的对象是事务，用来锁定的是数据库中的对象，如表、页、行。一般 lock 的对象仅在事务 commit 或 rollback 后进行释放（不用事务隔离级别释放的时间可能不同）。有死锁机制。

## 锁的类型
InnoDB 存储引擎实现了两种标准的行级锁：
1. 共享锁（S Lock）：允许事务读一行数据。 如果一个事务 T1 已经获得了行 r 的共享锁，那么另外的事务 T2 可以立即获得行r的共享锁。因为读取并没有改变行 r 的数据，称这种情况为锁兼容。
2. 排他锁（X Lock）：允许事务删除或更新一行数据。 若事务 T3 想获取行 r 的排它锁，则其必须等待其他事务 T1、T2 释放行 r 上的共享锁，这种情况称为锁不兼容。

> X 锁与任何锁都不兼容，S 锁仅与 S 锁兼容

## 锁粒度
Innodb 支持多粒度锁定，即允许事务在行级上的锁和表级上的锁同时存在。为了支持在不同粒度上进行加锁操作，InnoDB 存储引擎支持一种额外的锁方式-意向锁。   

**InnoDB 存储引擎支持意向锁设计比较简单，其意向锁即为表级别的锁。意向锁是一种不与行级锁冲突表级锁. 由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫描以外的任何请求。**其支持两种意向锁：        
* 意向共享锁（IS LOCK）事务想要获取一张表中某几行的共享锁
* 意向排它锁（IX LOCK）事务想要获取一张表中某几行的排它锁。

> 意向锁是将锁定的对象分为多个层次，意向锁意味着事务希望在更细粒度上进行加锁。     

> 意向锁是由存储引擎维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB会先获取该数据行所在在数据表对应的意向锁。         
若将上锁的对象看成一棵树，那么对最下层的对象上锁，也就是对最细粒度的对象进行上锁，那么首先需要对粗粒度的对象上锁。

![存储概览](/img/mysql/Ilock.png)


## 一致性非锁定读
InnoDB 存储引擎通过 “行多版本控制” 的方式来读取 当前执行时间 数据库中行的数据。如果读取的行正在执行 delete 或 update 操作，这时读取操作不会因此去等待行上锁的释放。相反的，InnoDB 会去读取行的一个快照数据。**这是默认的读取方式，即读取不会占用或等待表上的锁。**    

![存储概览](/img/mysql/snapshot.png)   

**在不同的事务隔离级别下，读取的方式不同，并不是在每个事务隔离级别下都有采用非锁定的一致性读：**    
1. 在事务隔离级别 Read Committed， InnoDB 存储引擎使用非锁定的一致性读。对于快照数据，非一致性读总是读取被锁定行的最新一份快照数据。
对于 Read Committed 事务隔离级别，它总是读取行的最新版本。如果行被锁定了，则读取该行版本的最新一个快照。其违反了 ACID 中的 I 隔离性。

2. 在事务隔离级别 Repeatable Read，对于快照数据，非一致性读总是读取事务开始时的行版本数据。

> 快照数据：行的之前版本数据，该实现是通过 undo段 来实现。读取快照数据是不需要上锁的，因为没有事务需要对历史的数据进行修改操作。


## 一致性锁定读
显示的对数据库读取操作进行加锁以保证数据逻辑的一致性: 
* select ... for update: 对读取的行记录加 X 锁
* select ... lock in share mode: 对读取的行加 S 锁

#### 外键和锁
对于外键值的插入和更新，首先需要查询父表中的记录，即 select 父表。但是对于父表的 select 操作，不是使用一致性非锁定读的方式，因为这样会发生数据不一致的问题，所以使用的是 select ... lock in share mode 方式，即主动对父表加一个s锁，如果这时父表已经这样加X锁，子表上的操作会被阻塞。

> 外键： 主要用于引用完整性的约束检查。在 InnoDB 存储引擎中，对于一个外键列，如果没有显示的对这个列加索引，InnoDB 存储引擎会自动对其加一个索引，这样能够避免表锁.

#### 行锁算法
InnoDB 存储引擎有 3 种行锁算法：
* Record Lock: 单个行记录上的锁。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Locks 依然可以使用。
* Gap lock: 间隙锁，锁定一个范围，但不包括记录本身。GAP 锁的目的，是为了防止同一事务的两次当前读，出现幻读的情况。
* Next-key lock: 锁定一个范围，并且锁定记录本身。对于行的查询，都是采用该方法，主要目的是解决幻读的问题。

> **Record Lock 总是会去锁定索引记录。如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么InnoDB存储引擎会使用隐式的主键来进行锁定**

InnoDB 存储引擎对于**行的查询**采用 Next-key Lock锁定算法。采用 Next-key Lock 锁定技术称为 Next-key Locking，其设计的目的是为了解决幻读。    
当查询的索引是唯一索引时，InnoDB储存引擎会对 Next-key Lock进行优化，将其降级为Record Lock，即仅锁住索引本身，而不是范围。    
对于辅助索引，加 Next-key Lock，除此之外，还会对辅助索引的下一个键值加上Gap Lock。**Gap 锁的作用是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生。**       

在 InnoDB 存储引擎中，对于 Insert 的操作，其会检查插入记录的下一条记录是否被锁定，若已经被锁定，则不允许查询。


## 锁问题
用过锁定机制可以实现事务的隔离级别的要求

#### 脏读
脏数据 是指还未提交的数据。如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，则显然违反了数据库的隔离型。脏读发生的条件是需要事务的隔离级别为 Read uncommited。

#### 不可重复读（幻读）
在一个事务下，连续执行两次相同的 SQL 语句可能导致不同的结果，第二次的 SQL 语句可能会返回之前不存在的行。不可重复度和脏读的区别是：脏读是读到未提交的数据，而不可重复读读到的却是已经提交的数据，但是其违反了数据库事务一致性的要求。

在 InnodDB存储引擎中，通过使用 Next-Key Lock算法来避免不可重读问题。在 Next-Key Lock算法下，对于索引的扫描，不仅是锁住扫描到的索引，而且还锁住那些索引覆盖的范围（gap），因此在这个范围内插入都是不被允许的。

> 用户可以通过 InnoDB存储引擎的 Next-Key Lock机制在应用层面实现唯一性检查，例如：   
```  
  select * from table where col = XXX in share mode;      
    if not found any row:     
       insert into table values(...);      
```

如果用户**通过索引**查询一个值，并对该行加上一个SLock，那么即使查询的值不存在，其锁定的也是一个范围，因此若没有返回任何行，那么新插入的值一定是唯一的。   
       

#### 丢失更新
一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。     
**在当前数据库的任何隔离级别下，都不会导致数据库理论意义上的丢失更新问题**    
要避免丢失更新操作，需要让事务的操作变成串行化，而不是并行操作

#### 阻塞
因为不同锁之间的兼容性问题，在有些时刻一个事务中的锁需要等待另一个事务中的锁释放它锁占用的资源，这就是阻塞。
在默认情况下，InnoDB 存储引擎不会回滚超时引发的错误异常，

#### 死锁
死锁是指两个或两个以上的事务在执行过程中，因争夺锁资源而造成的一种相互等待的现象。   

###### 解决死锁问题的方法
* 超时：当两个事务相互等待时，当一个等待时间超过设置的某一阈值时，其中一个事务进行回滚，另一个等待的事务就能继续进行。
* 采用 wait-for graph 等待图的方式进行死锁检测：更为主动的进行死锁检查。在每个事务请求锁并发生等待时都会判断是否存在回路，如存在则有死锁。通常InnoDB存储引擎选择回滚undo量最小的事务。

**InnoBD 不会回滚大部分的错误异常，但死锁除外**

#### 锁升级
将当前锁的粒度降低。
InnoDB 不存在锁升级的问题。**因为其不是根据每个记录来产生行锁的，相关，其根据每个事务访问的每个页对锁进行管理的，采用了位图的方式.** 因此不管一个事务锁住页中一个记录还是多个记录，其开销通常都是一致的。

## 命令：
```
show engine innodb status // 查看当前锁请求的信息
```

```
select * from information_schema.INNODB_TRX\G    // 查询当前运行的InnoDB事务
```
![存储概览](/img/mysql/rax.png)

```
select * from information_schema.INNODB_LOCKS\G     // 查看锁信息
```
![存储概览](/img/mysql/lock_rac.png)

```
select * from information_schema.INNODB_LOCK_WAITS\G     // 查看当前事务的等待
```
![存储概览](/img/mysql/lock_wait.png)

```
show processlist; or show full processlist;   //  参看当前运行的事务
```


## 参考文献
https://www.cnblogs.com/geaozhang/p/7287108.html