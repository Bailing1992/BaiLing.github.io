---
layout: post
title: "MySQL 系列 隔离级别"
subtitle: '《Mysql 技术内幕：InnoDB存储引擎》'
author: "lichao"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
  - MySQL
---

> 事务（Transaction）是由一系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。数据库事务的四大特性（ACID）
![存储概览](/img/mysql/1.png)

#### 四大特性（ACID）
1. 原子性（Atomicity）
事务原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，只允许出现两种状态之一:
  * 全部执行成功
  * 全部执行失败
任何一项操作都会导致整个事务的失败，同时其它已经被执行的操作都将被撤销并回滚，只有所有的操作全部成功，整个事务才算是成功完成。

2. 一致性（Consistency）
事务一致性是指事务的执行不能破坏数据库数据的完整性和一致性，一个事务在执行之前和执行之后，数据库都必须处以一致性状态。比如：如果从A账户转账到B账户，不可能因为A账户扣了钱，而B账户没有加钱。

3. 隔离性（Isolation）
事务隔离性是指在并发环境中，并发的事务是互相隔离的，一个事务的执行不能被其它事务干扰。也就是说，不同的事务并发操作相同的数据时，每个事务都有各自完整的数据空间。
在标准SQL规范中，定义了 4 个事务隔离级别，不同的隔离级别对事务的处理不同。4个隔离级别分别是：读未提交（READ_UNCOMMITTED）、读已提交（READ_COMMITTED）、可重复读（REPEATABLE_READ）、顺序读（SERIALIZABLE）;

事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务是不能互相干扰的。

4. 持久性（Durability）
事务持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器系统崩溃或服务器宕机等故障。只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。

隔离级别说明：

MySQL定义了四种隔离级别，包括一些具体规则，用于限定事务内外哪些改变是可见的，哪些改变是不可见的。低级别的隔离一般支持更高的并发处理，并且拥有更低的系统开销。

* REPEATABLE READ 可重复读：
MySQL 数据库默认的隔离级别。因此该事务级别进制了不可重复读取和脏读。但是有可能出现幻读的数据。InnoDB和Falcon存储引擎通过多版本并发控制机制解决了幻读问题。幻读就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。幻读示例：
		
* READ COMMITTED读取提交内容
大多数数据库系统的默认隔离级别（但是不是MySQL的默认隔离级别），满足了隔离的早先简单定义：一个事务开始时，只能“看见”已经提交事务所做的改变，一个事务从开始到提交前，所做的任何数据改变都是不可见的，除非已经提交。这种隔离级别同样是“不可重复读”，这意味着用户运行同一个语句两次，看到的结果是不同的。
	
事务 A 其实除了查询两次以外，其它什么事情都没做，结果钱就从1000编程0了，这就是不可重复读的问题。
* READ UNCOMMITTED 读取未提交内容
此隔离级别，所有事务都可以“看到”未提交事务的执行结果。其隔离级别是最低的。读取未提交数据，也被称为“脏读”，脏读示例：
	
余额应该为1500元才对。请看T5时间点，事务A此时查询的余额为0，这个数据就是脏数据，他是事务B造成的，很明显是事务没有进行隔离造成的。
* SERIALIZABLE可串行化
该级别是最高级别的隔离级。它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简而言之，SERIALIZABLE是在每个读的数据行上加锁。在这个级别，可能导致大量的超时Timeout和锁竞争Lock Contention现象，实际应用中很少使用到这个级别，但如果用户的应用为了数据的稳定性，需要强制减少并发的话，也可以选择这种隔离级

下面的表格总结了各种隔离级别和各自的缺点：
	
以上四种隔离级别最高的是Serializable级别，最低的是Read uncommitted级别，当然级别越高，执行效率就越低。像 Serializable 这样的级别，就是以锁表的方式(类似于Java多线程中的锁)使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况.

在MySQL数据库中，支持上面四种隔离级别，默认的为 Repeatable read (可重复读)；而在Oracle数据库中，只支持 Serializable (串行化)级别和Read committed (读已提交)这两种级别，其中默认的为Read committed级别。

#### 数据库并发问题
1. 脏读
脏读是指在一个事务处理过程中读取了另一个未提交的事务中的数据。

2. 不可重复读
　　不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的值，这是由于在查询间隔中，被另一个事务修改并提交了。
　  不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。
　　在某些情况下，不可重复读并不是问题，比如我们多次查询某个数据当然以最后查询得到的结果为主。但在另一些情况下就有可能发生问题，例如对于同一个数据A和B依次查询就可能不同，A和B就可能打起来了

3. 虚读(幻读)
幻读是事务非独立执行时发生的一种现象。例如事务 T1 对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务 T2 又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务 T1 的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务 T2 中添加的，就好像产生幻觉一样，这就是发生了幻读

幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）

#### 相关SQL命令： 　　
* 在MySQL数据库中查看当前事务的隔离级别：
```
  select @@tx_isolation; 
```
* 在MySQL数据库中设置事务的隔离级别：
```
	set  [glogal | session]  transaction isolation level 隔离级别名称; 或：
  set tx_isolation=’隔离级别名称;’ 
```

设置数据库的隔离级别一定要在开启事务之前，如果是使用JDBC对数据库的事务设置隔离级别的话，也应该是在调用Connection对象的setAutoCommit(false)方法之前。调用Connection对象的setTransactionIsolation(level)即可设置当前链接的隔离级别，至于参数level，可以使用Connection对象的字段：
	

在JDBC中设置隔离级别的部分代码：
	
后记：隔离级别的设置只对当前链接有效。对于使用MySQL命令窗口而言，一个窗口就相当于一个链接，当前窗口设置的隔离级别只对当前窗口中的事务有效；对于JDBC操作数据库来说，一个Connection对象相当于一个链接，而对于Connection对象设置的隔离级别只对该Connection对象有效，与其他链接Connection对象无关。
