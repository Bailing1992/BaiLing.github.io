---
layout: post
title: "RocketMQ 系列 存储设计"
subtitle: '刨析rocketMQ的底层实现'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - rocketMQ
---

## 相关概念
#### tag 标签
标签，即子主题，为用户提供了额外的灵活性。有了标签，来自同一业务模块的具有不同目的的消息可以具有相同的主题和不同的标签。标签有助于保持代码的清晰和连贯，同时标签也方便RocketMQ提供的查询功能。    
在Producer中使用Tag：    
```
Message msg = new Message("TopicTest",
                    "TagA" /* Tag */,
                    ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
```
在Consumer中订阅Tag：    
```
consumer.subscribe("TopicTest", "TagA||TagB");// * 代表订阅Topic下的所有消息
```

#### group 组

代表具有相同角色的生产者组合或消费者组合，称为生产者组或消费者组。

#### keys
可以设置业务相关标识，用于消费处理判定，或消息追踪查询.   
尽管 Broker 不会对消息进行 Key 相关的过滤(并不属于服务端消息过滤的功能)，但是会为消息定制相应的索引，提供了一种较精确的查询指定消息的功能。   
在发送消息之前可以为消息设定指定的 Key，通常这个 Key 是在业务层面是唯一的：   
```
Message msg = new Message("Topic", "Tag", "Content".getBytes());
msg.setKey(uniqueKey);
```   

#### commit log： 
文件集合，每个文件1G大小，存储满后存下一个，所有消息内容全部持久化到这个文件中。

#### commit queue：
一个topic可以有多个，每个文件代表一个逻辑队列，**这里存放消息在 commit log中的偏移量以及大小和tag属性。**


#### Page Cache
通常文件读写比较慢，如果对文件进行顺序读写，速度几乎是接近于内存的随机读写，为什么会这么快，原因就是**Page Cache。**   
OS发现系统的物理内存有大量剩余时，为了提高IO的性能，就会使用多余的内存当做文件缓存，Page Cache就是这些内存的子集。   
OS在读磁盘时会将当前区域的内容全部读到Cache中，以便下次读时能命中Cache，写磁盘时直接写到Cache中就写返回，由OS的pdflush以某些策略将Cache的数据Flush回磁盘。   
但是系统上文件非常多，即使是多余的Page Cache也是非常宝贵的资源，OS不可能将Page Cache随机分配给任何文件，Linux底层就提供了mmap将一个程序指定的文件映射进虚拟内存（Virtual Memory），对文件的读写就变成了对内存的读写，能充分利用Page Cache。不过，文件IO仅仅用到了Page Cache还是不够的，如果对文件进行随机读写，会使虚拟内存产生很多缺页（Page Fault）中断。
![存储概览](/img/rocketmq/mmap.png)

每个用户空间的进程都有自己的虚拟内存，每个进程都认为自己所有的物理内存，但虚拟内存只是逻辑上的内存，要想访问内存的数据，还得通过内存管理单元（MMU）查找页表，将虚拟内存映射成物理内存。如果映射的文件非常大，程序访问局部映射不到物理内存的虚拟内存时，产生缺页中断，OS需要读写磁盘文件的真实数据再加载到内存。如同我们的应用程序没有Cache住某块数据，直接访问数据库要数据再把结果写到Cache一样，这个过程相对而言是非常慢的。

但是顺序IO时，读和写的区域都是被OS智能Cache过的热点区域，不会产生大量缺页中断，文件的IO几乎等同于内存的IO，性能当然就上去了。

说了这么多Page Cache的优点，也得稍微提一下它的缺点，内核把可用的内存分配给Page Cache后，free的内存相对就会变少，如果程序有新的内存分配需求或者缺页中断，恰好free的内存不够，内核还需要花费一点时间将热度低的Page Cache的内存回收掉，对性能非常苛刻的系统会产生毛刺。

#### pdflush
刷盘一般分成：同步刷盘和异步刷盘
![存储概览](/img/rocketmq/flush.png)
* 同步刷盘
在消息真正落盘后，才返回成功给Producer，只要磁盘没有损坏，消息就不会丢。   
![存储概览](/img/rocketmq/syn_flush.png)
一般只用于金融场景，这种方式不是本文讨论的重点，因为没有利用Page Cache的特点，不管数据量大小，每次刷盘的时间几乎都是相同的，因此RMQ采用GroupCommit（锁粗化）的方式对同步刷盘进行了优化。    
* 异步刷盘
读写文件充分利用了Page Cache，即写入Page Cache就返回成功给Producer，RMQ中有两种方式进行异步刷盘，整体原理是一样的。
当程序顺序写文件时，首先写到Cache中，这部分被修改过，但却没有被刷进磁盘，产生了不一致，这些不一致的内存叫做脏页（Dirty Page）.   
![存储概览](/img/rocketmq/fsync.png)
脏页设置太小，Flush磁盘的次数就会增加，性能会下降；脏页设置太大，性能会提高，但万一OS宕机，脏页来不及刷盘，消息就丢了。

## 实例分析：
假如集群有一个broker，topic为“biglog”的队列（consume queue）数量为4，按顺序发送这5条数据。
![存储概览](/img/rocketmq/message.png)

这时commit log 和consume queue的内容结构为：

![存储概览](/img/rocketmq/commitlog.png)


rocketMQ消息整体是有序的，所以这5条消息按顺序将内容持久化到commit log 中，**consume queue则是用于将消息均衡地按序排列在不同的逻辑队列。**集群模式下多个消费者就可以并行消费consume queue的消息






## 问题：
#### rocketMQ采用了什么存储方案？
#### 这种存储方案为什么能带来性能的提升？
顺序读写、异步刷盘
![存储概览](/img/rocketmq/page_flaut.png)
RMQ想要性能高，那发送消息时，消息要写进Page Cache而不是直接写磁盘，接收消息时，消息要从Page Cache直接获取而不是缺页从磁盘读取。
**RMQ发送逻辑**
发送时，Producer不直接与Consume Queue打交道。RMQ所有的消息都会存放在Commit Log中，为了使消息存储不发生混乱，对Commit Log进行写之前就会上锁。    
![存储概览](/img/rocketmq/sent.png)    
消息持久被锁串行化后，对Commit Log就是顺序写，也就是常说的Append操作。配合上Page Cache，RMQ在写Commit Log时效率会非常高。     
Commit Log 持久后，会将里面的数据Dispatch到对应的Consume Queue上。     
![存储概览](/img/rocketmq/dispatch.png)  
每一个Consume Queue代表一个逻辑队列，是由ReputMessageService在单个Thread Loop中Append，显然也是顺序写。

**消费逻辑底层**
消费时，Consumer不直接与Commit Log打交道，而是从Consume Queue中去拉取数据

![存储概览](/img/rocketmq/consume.png)    

拉取的顺序从旧到新，在文件表示每一个Consume Queue都是顺序读，充分利用了Page Cache。光拉取Consume Queue是没有数据的，里面只有一个对Commit Log的引用，所以再次拉取Commit Log。


![存储概览](/img/rocketmq/consume2.png)    

Commit Log会进行随机读:
![存储概览](/img/rocketmq/randomRead.png)    
但整个RMQ只有一个Commit Log，虽然是随机读，但整体还是有序地读，只要那整块区域还在Page Cache的范围内，还是可以充分利用Page Cache。