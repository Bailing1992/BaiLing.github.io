---
layout: post
title: "RocketMQ 系列 存储设计"
subtitle: '刨析rocketMQ的底层实现'
author: "lichao"
header-img: "img/post-bg-rwd.jpg"
catalog: true
tags:
  - rocketMQ
---

## 相关概念
#### tag 标签
标签，即子主题，为用户提供了额外的灵活性。有了标签，来自同一业务模块的具有不同目的的消息可以具有相同的主题和不同的标签。标签有助于保持代码的清晰和连贯，同时标签也方便RocketMQ提供的查询功能。    
在Producer中使用Tag：    
```
Message msg = new Message("TopicTest",
                    "TagA" /* Tag */,
                    ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
```
在Consumer中订阅Tag：    
```
consumer.subscribe("TopicTest", "TagA||TagB");// * 代表订阅Topic下的所有消息
```

#### group 组

代表具有相同角色的生产者组合或消费者组合，称为生产者组或消费者组。

#### keys
可以设置业务相关标识，用于消费处理判定，或消息追踪查询.   
尽管 Broker 不会对消息进行 Key 相关的过滤(并不属于服务端消息过滤的功能)，但是会为消息定制相应的索引，提供了一种较精确的查询指定消息的功能。   
在发送消息之前可以为消息设定指定的 Key，通常这个 Key 是在业务层面是唯一的：   
```
Message msg = new Message("Topic", "Tag", "Content".getBytes());
msg.setKey(uniqueKey);
```   

#### commit log： 
文件集合，每个文件1G大小，存储满后存下一个，所有消息内容全部持久化到这个文件中。     

**消息存储协议:**

Commitlog 文件存储的逻辑视图如下图所示，每条消息的前面4个字节存储该条消息的总长度。
![存储概览](/img/rocketmq/commitlogModel.png) 

**消息存储格式如下:**

![存储概览](/img/rocketmq/CommitLogItem.jpg)
RocketMQ 以如下图所示存储格式将消息顺序写入 CommitLog。除了记录消息本身的属性（消息长度、消息体、Topic 长度、Topic、消息属性长度和消息属性），CommitLog 同时记录了消息所在消费队列的信息（消费队列 ID 和偏移量)。由于存储条目具备不定长的特性，当 CommitLog 剩余空间无法满足消息时，CommitLog 在尾部追加一个 MAGIC CODE 等于 BLANK_MAGIC_CODE 的存储条目作为结束标记，并将消息存储至下一个 CommitLog 文件。
1. TOTALSIZE：该消息条目总长度，4字节。
2. MAGICCODE：魔数，4字节。固定值Oxdaa320a7。
3. BODYCRC：消息体ere校验码， 4字节。
4. QUEUEID：消息消费队列ID , 4 字节。
5. FLAG：消息FLAG , RocketMQ 不做处理，供应用程序使用，默认4字节。
6. QUEUEOFFSET ：消息在消息消费队列的偏移量， 8 字节。
7. PHYSICALOFFS E T ： 消息在CommitLog 文件中的偏移量， 8 字节。
8. SYSFLAG ： 消息系统Flag ，例如是否压缩、是否是事务消息等， 4 字节。
9. BORNTIMESTA M P ： 消息生产者调用消息发送API 的时间戳， 8 字节。
10. BORNHOST ：消息发送者IP 、端口号， 8 字节。
11. STORETIMESTAMP ： 消息存储时间戳， 8 字节。
12. STOREHOSTADDRESS: Broker 服务器IP＋ 端口号， 8 字节。
13. RECONSUMETIMES ： 消息重试次数， 4 字节。
14. Prepared Transaction Offs et ： 事务消息物理偏移量， 8 字节。
15. BodyLength ：消息体长度，4字节。
16. Body ： 消息体内容，长度为bodyLenth中存储的值。
17. TopieLength：主题存储长度，1字节，**表示主题名称不能超过255 个字符**。
18. Topie ： 主题，长度为TopicLength 中存储的值
19. PropertiesLength ： 消息属性长度，2字节， 表示消息属性长度不能超过65536个
字符。
20. Properties ： 消息属性，长度为PropertiesLength 中存储的值。     

**存储过程**   

1. 在写入commitlog之前，先申请Lock（putMessageLock），也就是将消息存储到CommitLog文件中是串行锁。
2. 创建全局唯一消息ID，消息ID有16字节，消息ID的组成如下图：
![存储概览](/img/rocketmq/id.png)
这样生成ID的好处：为了消息ID可读性，返回给应用程序的msgld 为字符类型，可以通过 UtilAll.bytes2string 方法将 msgld 字节数组转换成字符串，通过Uti1All.string2bytes 方法将 msgld字符串还原成16 个字节的字节数组，从而根据提取消息偏移量，可以快速通过msgld 找到消息内容。
3. 获取该消息在消息队列的偏移量。CommitLog 中保存了当前所有消息队列的当前待写入偏移量。
4. 根据消息、体的长度、主题的长度、属性的长度结合消息存储格式计算消息的总长度。

#### commit queue：
一个topic 可以有多个，每个文件代表一个逻辑队列，**这里存放消息在commit log中的偏移量以及大小和tag属性。**


#### Page Cache
通常文件读写比较慢，如果对文件进行顺序读写，速度几乎是接近于内存的随机读写，为什么会这么快，原因就是**Page Cache。**   
OS发现系统的物理内存有大量剩余时，为了提高IO的性能，就会使用多余的内存当做文件缓存，Page Cache就是这些内存的子集。   
OS在读磁盘时会将当前区域的内容全部读到Cache中，以便下次读时能命中Cache，写磁盘时直接写到Cache中就写返回，由OS的pdflush以某些策略将Cache的数据Flush回磁盘。   
但是系统上文件非常多，即使是多余的Page Cache也是非常宝贵的资源，OS不可能将Page Cache随机分配给任何文件，Linux底层就提供了mmap将一个程序指定的文件映射进虚拟内存（Virtual Memory），对文件的读写就变成了对内存的读写，能充分利用Page Cache。不过，文件IO仅仅用到了Page Cache还是不够的，如果对文件进行随机读写，会使虚拟内存产生很多缺页（Page Fault）中断。
![存储概览](/img/rocketmq/mmap.png)

每个用户空间的进程都有自己的虚拟内存，每个进程都认为自己所有的物理内存，但虚拟内存只是逻辑上的内存，要想访问内存的数据，还得通过内存管理单元（MMU）查找页表，将虚拟内存映射成物理内存。如果映射的文件非常大，程序访问局部映射不到物理内存的虚拟内存时，产生缺页中断，OS需要读写磁盘文件的真实数据再加载到内存。如同我们的应用程序没有Cache住某块数据，直接访问数据库要数据再把结果写到Cache一样，这个过程相对而言是非常慢的。

但是顺序IO时，读和写的区域都是被OS智能Cache过的热点区域，不会产生大量缺页中断，文件的IO几乎等同于内存的IO，性能当然就上去了。

说了这么多Page Cache的优点，也得稍微提一下它的缺点，内核把可用的内存分配给Page Cache后，free的内存相对就会变少，如果程序有新的内存分配需求或者缺页中断，恰好free的内存不够，内核还需要花费一点时间将热度低的Page Cache的内存回收掉，对性能非常苛刻的系统会产生毛刺。

#### pdflush
刷盘一般分成：同步刷盘和异步刷盘
![存储概览](/img/rocketmq/flush.png)
* 同步刷盘
在消息真正落盘后，才返回成功给Producer，只要磁盘没有损坏，消息就不会丢。   
![存储概览](/img/rocketmq/syn_flush.png)
一般只用于金融场景，这种方式不是本文讨论的重点，因为没有利用Page Cache的特点，不管数据量大小，每次刷盘的时间几乎都是相同的，因此RMQ采用GroupCommit（锁粗化）的方式对同步刷盘进行了优化。    
* 异步刷盘
读写文件充分利用了Page Cache，即写入Page Cache就返回成功给Producer，RMQ中有两种方式进行异步刷盘，整体原理是一样的。
当程序顺序写文件时，首先写到Cache中，这部分被修改过，但却没有被刷进磁盘，产生了不一致，这些不一致的内存叫做脏页（Dirty Page）.   
![存储概览](/img/rocketmq/fsync.png)
脏页设置太小，Flush磁盘的次数就会增加，性能会下降；脏页设置太大，性能会提高，但万一OS宕机，脏页来不及刷盘，消息就丢了。

## 实例分析：
假如集群有一个broker，topic为“biglog”的队列（consume queue）数量为4，按顺序发送这5条数据。
![存储概览](/img/rocketmq/message.png)

这时commit log 和consume queue的内容结构为：

![存储概览](/img/rocketmq/commitlog.png)


rocketMQ消息整体是有序的，所以这5条消息按顺序将内容持久化到commit log 中，**consume queue则是用于将消息均衡地按序排列在不同的逻辑队列。**集群模式下多个消费者就可以并行消费consume queue的消息


## 问题：
#### rocketMQ 
#### rocketMQ采用了什么存储方案？
#### 这种存储方案为什么能带来性能的提升？
顺序读写、异步刷盘
![存储概览](/img/rocketmq/page_flaut.png)
RMQ想要性能高，那发送消息时，消息要写进Page Cache而不是直接写磁盘，接收消息时，消息要从Page Cache直接获取而不是缺页从磁盘读取。
**RMQ发送逻辑**
发送时，Producer不直接与Consume Queue打交道。RMQ所有的消息都会存放在Commit Log中，为了使消息存储不发生混乱，对Commit Log进行写之前就会上锁。    
![存储概览](/img/rocketmq/sent.png)    
消息持久被锁串行化后，对Commit Log就是顺序写，也就是常说的Append操作。配合上Page Cache，RMQ在写Commit Log时效率会非常高。     
Commit Log 持久后，会将里面的数据Dispatch到对应的Consume Queue上。     
![存储概览](/img/rocketmq/dispatch.png)  
每一个Consume Queue代表一个逻辑队列，是由ReputMessageService在单个Thread Loop中Append，显然也是顺序写。

**消费逻辑底层**
消费时，Consumer不直接与Commit Log打交道，而是从Consume Queue中去拉取数据

![存储概览](/img/rocketmq/consume.png)    

拉取的顺序从旧到新，在文件表示每一个Consume Queue都是顺序读，充分利用了Page Cache。光拉取Consume Queue是没有数据的，里面只有一个对Commit Log的引用，所以再次拉取Commit Log。


![存储概览](/img/rocketmq/consume2.png)    

Commit Log会进行随机读:
![存储概览](/img/rocketmq/randomRead.png)    
但整个RMQ只有一个Commit Log，虽然是随机读，但整体还是有序地读，只要那整块区域还在Page Cache的范围内，还是可以充分利用Page Cache。

#### 魔数的作用？
首先判断文件的魔数，如果文件的魔数不对，说明不是消息的存储文件。直接返回false.
按照当初存储消息的顺序来进行读取消息：
1. 读取消息总大小
2. 读取消息魔数
  * 如果魔数是MESSAGE_MAGIC_CODE，那么走到3
  * 如果魔数是BLANK_MAGIC_CODE, 说明是空白填充，直接返回。size = 0, success = true.
  * 如果是别的那么打印warn级别日志，并返回异常。 size = -1 , success = false.
3. 读取一系列的msg属性
